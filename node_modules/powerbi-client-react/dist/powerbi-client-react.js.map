{"version":3,"sources":["webpack://powerbi-client-react/webpack/universalModuleDefinition","webpack://powerbi-client-react/webpack/bootstrap","webpack://powerbi-client-react/external \"powerbi-client\"","webpack://powerbi-client-react/external \"react\"","webpack://powerbi-client-react/external \"lodash.isequal\"","webpack://powerbi-client-react/./src/PowerBIEmbed.tsx","webpack://powerbi-client-react/./src/utils.ts"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__0__","__WEBPACK_EXTERNAL_MODULE__1__","__WEBPACK_EXTERNAL_MODULE__2__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","EmbedType","props","containerRef","prevEventHandlerMapString","service","powerbi","Service","hpmFactory","wpmpFactory","routerFactory","this","_embed","newEmbedInstance","invokeGetEmbedCallback","componentDidMount","current","embedConfig","accessToken","embedUrl","embedEntity","embed","bootstrap","eventHandlers","setEventHandlers","componentDidUpdate","prevProps","embedOrUpdateAccessToken","settings","updateSettings","type","Report","filters","prevEmbedConfig","pageName","setPage","setFilters","removeFilters","console","error","componentWillUnmount","reset","render","ref","className","cssClassName","phasedEmbedding","load","setAccessToken","catch","eventHandlerMap","eventHandlerMapString","map","mapEntries","Array","from","JSON","stringify","mapEntry","toString","stringifyMap","allowedEvents","entityType","embedtype","Dashboard","Tile","Qna","Visual","invalidEvents","forEach","eventHandlerMethod","eventName","includes","off","on","event","push","length","join","getEmbeddedComponent"],"mappings":"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","file":"powerbi-client-react.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"powerbi-client\"), require(\"react\"), require(\"lodash.isequal\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"powerbi-client\", \"react\", \"lodash.isequal\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"powerbi-client-react\"] = factory(require(\"powerbi-client\"), require(\"react\"), require(\"lodash.isequal\"));\n\telse\n\t\troot[\"powerbi-client-react\"] = factory(root[\"powerbi-client\"], root[\"react\"], root[\"lodash.isequal\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__, __WEBPACK_EXTERNAL_MODULE__1__, __WEBPACK_EXTERNAL_MODULE__2__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","module.exports = __WEBPACK_EXTERNAL_MODULE__2__;","// Copyright (c) Microsoft Corporation.\r\n// Licensed under the MIT License.\r\n\r\nimport * as React from 'react';\r\nimport {\r\n\tservice,\r\n\tfactories,\r\n\tReport,\r\n\tEmbed,\r\n\tDashboard,\r\n\tTile,\r\n\tQna,\r\n\tVisual,\r\n\tIEmbedSettings,\r\n\tIEmbedConfiguration,\r\n\tIQnaEmbedConfiguration,\r\n\tIVisualEmbedConfiguration,\r\n\tIReportEmbedConfiguration,\r\n\tIDashboardEmbedConfiguration,\r\n\tITileEmbedConfiguration,\r\n} from 'powerbi-client';\r\nimport { ReportLevelFilters } from 'powerbi-models';\r\nimport isEqual from 'lodash.isequal';\r\nimport { stringifyMap } from './utils';\r\n\r\n/**\r\n * Type for event handler function of embedded entity\r\n */\r\nexport type EventHandler = {\r\n\t(event?: service.ICustomEvent<any>, embeddedEntity?: Embed): void | null;\r\n};\r\n\r\n/**\r\n * Props interface for PowerBIEmbed component\r\n */\r\nexport interface EmbedProps {\r\n\r\n\t// Configuration for embedding the PowerBI entity (Required)\r\n\tembedConfig:\r\n\t\t| IReportEmbedConfiguration\r\n\t\t| IDashboardEmbedConfiguration\r\n\t\t| ITileEmbedConfiguration\r\n\t\t| IQnaEmbedConfiguration\r\n\t\t| IVisualEmbedConfiguration\r\n\t\t| IEmbedConfiguration;\r\n\r\n\t// Callback method to get the embedded PowerBI entity object (Optional)\r\n\tgetEmbeddedComponent?: { (embeddedComponent: Embed): void };\r\n\r\n\t// Map of pair of event name and its handler method to be triggered on the event (Optional)\r\n\teventHandlers?: Map<string, EventHandler>;\r\n\r\n\t// CSS class to be set on the embedding container (Optional)\r\n\tcssClassName?: string;\r\n\r\n\t// Phased embedding flag (Optional)\r\n\tphasedEmbedding?: boolean;\r\n\r\n\t// Provide a custom implementation of PowerBI service (Optional)\r\n\tservice?: service.Service;\r\n}\r\n\r\nexport enum EmbedType {\r\n\tReport = 'report',\r\n\tDashboard = 'dashboard',\r\n\tTile = 'tile',\r\n\tQna = 'qna',\r\n\tVisual = 'visual'\r\n}\r\n\r\n/**\r\n * Base react component to embed Power BI entities like: reports, dashboards, tiles, visual and qna containers.\r\n */\r\nexport class PowerBIEmbed extends React.Component<EmbedProps> {\r\n\r\n\t// Embedded entity\r\n\t// Note: Do not read or assign to this member variable directly, instead use the getter and setter\r\n\tprivate _embed?: Embed;\r\n\r\n\t// Powerbi service\r\n\tprivate powerbi: service.Service;\r\n\r\n\t// Ref to the HTML div element\r\n\tprivate containerRef = React.createRef<HTMLDivElement>();\r\n\r\n\t// JSON stringify of prev event handler map\r\n\tprivate prevEventHandlerMapString = '';\r\n\r\n\t// Getter for this._embed\r\n\tprivate get embed(): Embed | undefined {\r\n\t\treturn this._embed;\r\n\t};\r\n\r\n\t// Setter for this._embed\r\n\tprivate set embed(newEmbedInstance: Embed | undefined) {\r\n\t\tthis._embed = newEmbedInstance;\r\n\r\n\t\t// Invoke callback method in props to return this embed instance\r\n\t\tthis.invokeGetEmbedCallback();\r\n\t};\r\n\r\n\tconstructor(props: EmbedProps) {\r\n\t\tsuper(props);\r\n\r\n\t\tif (this.props.service) {\r\n\t\t\tthis.powerbi = this.props.service;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.powerbi = new service.Service(\r\n\t\t\t\tfactories.hpmFactory,\r\n\t\t\t\tfactories.wpmpFactory,\r\n\t\t\t\tfactories.routerFactory);\r\n\t\t}\r\n\t};\r\n\r\n\tcomponentDidMount(): void {\r\n\r\n\t\t// Check if HTML container is available\r\n\t\tif (this.containerRef.current) {\r\n\r\n\t\t\t// Decide to embed, load or bootstrap\r\n\t\t\tif (this.props.embedConfig.accessToken && this.props.embedConfig.embedUrl) {\r\n\t\t\t\tthis.embedEntity();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.embed = this.powerbi.bootstrap(this.containerRef.current, this.props.embedConfig);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Set event handlers if available\r\n\t\tif (this.props.eventHandlers && this.embed) {\r\n\t\t\tthis.setEventHandlers(this.embed, this.props.eventHandlers);\r\n\t\t}\r\n\t};\r\n\r\n\tasync componentDidUpdate(prevProps: EmbedProps): Promise<void> {\r\n\r\n\t\tthis.embedOrUpdateAccessToken(prevProps);\r\n\r\n\t\t// Set event handlers if available\r\n\t\tif (this.props.eventHandlers && this.embed) {\r\n\t\t\tthis.setEventHandlers(this.embed, this.props.eventHandlers);\r\n\t\t}\r\n\r\n\t\t// Allow settings update only when settings object in embedConfig of current and previous props is different\r\n\t\tif (!isEqual(this.props.embedConfig.settings, prevProps.embedConfig.settings)) {\r\n\t\t\tawait this.updateSettings();\r\n\t\t}\r\n\r\n\t\t// Update pageName and filters for a report\r\n\t\tif (this.props.embedConfig.type === EmbedType.Report) {\r\n\t\t\ttry {\r\n\t\t\t\t// Typecasting to IReportEmbedConfiguration\r\n\t\t\t\tconst embedConfig = this.props.embedConfig as IReportEmbedConfiguration;\r\n\t\t\t\tconst filters = embedConfig.filters as ReportLevelFilters[];\r\n\t\t\t\tconst prevEmbedConfig = prevProps.embedConfig as IReportEmbedConfiguration;\r\n\r\n\t\t\t\t// Set new page if available and different from the previous page\r\n\t\t\t\tif (embedConfig.pageName && embedConfig.pageName !== prevEmbedConfig.pageName) {\r\n\t\t\t\t\t// Upcast to Report and call setPage\r\n\t\t\t\t\tawait (this.embed as Report).setPage(embedConfig.pageName);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Set filters on the embedded report if available and different from the previous filter\r\n\t\t\t\tif (filters && !isEqual(filters, prevEmbedConfig.filters)) {\r\n\t\t\t\t\t// Upcast to Report and call setFilters\r\n\t\t\t\t\tawait (this.embed as Report).setFilters(filters);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Remove filters on the embedded report, if previously applied\r\n\t\t\t\telse if (!filters && prevEmbedConfig.filters) {\r\n\t\t\t\t\t// Upcast to Report and call removeFilters\r\n\t\t\t\t\tawait (this.embed as Report).removeFilters();\r\n\t\t\t\t}\r\n\t\t\t} catch (err) {\r\n\t\t\t\tconsole.error(err);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tcomponentWillUnmount(): void {\r\n\t\t// Clean Up\r\n\t\tif (this.containerRef.current) {\r\n\t\t\tthis.powerbi.reset(this.containerRef.current);\r\n\t\t}\r\n\t};\r\n\r\n\trender(): JSX.Element {\r\n\t\treturn (\r\n\t\t\t<div\r\n\t\t\t\tref={this.containerRef}\r\n\t\t\t\tclassName={this.props.cssClassName}>\r\n\t\t\t</div>\r\n\t\t)\r\n\t};\r\n\r\n\t/**\r\n\t * Embed the powerbi entity (Load for phased embedding)\r\n\t */\r\n\tprivate embedEntity(): void {\r\n\t\t// Check if the HTML container is rendered and available\r\n\t\tif (!this.containerRef.current) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Load when props.phasedEmbedding is true and embed type is report, embed otherwise\r\n\t\tif (this.props.phasedEmbedding && this.props.embedConfig.type === EmbedType.Report) {\r\n\t\t\tthis.embed = this.powerbi.load(this.containerRef.current, this.props.embedConfig);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (this.props.phasedEmbedding) {\r\n\t\t\t\tconsole.error(`Phased embedding is not supported for type ${this.props.embedConfig.type}`)\r\n\t\t\t}\r\n\t\t\tthis.embed = this.powerbi.embed(this.containerRef.current, this.props.embedConfig);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * When component updates, choose to _embed_ the powerbi entity or _update the accessToken_ in the embedded entity \r\n\t * or do nothing if the embedUrl and accessToken did not update in the new props\r\n\t * \r\n\t * @param prevProps EmbedProps\r\n\t * @returns void\r\n\t */\r\n\tprivate embedOrUpdateAccessToken(prevProps: EmbedProps): void {\r\n\r\n\t\t// Check if Embed URL and Access Token are present in current props\r\n\t\tif (!this.props.embedConfig.accessToken || !this.props.embedConfig.embedUrl) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Embed or load in the following scenarios\r\n\t\t//\t\t1. AccessToken was not provided in prev props (E.g. Report was bootstrapped earlier)\r\n\t\t//\t\t2. Embed URL is updated (E.g. New report is to be embedded)\r\n\t\tif (\r\n\t\t\tthis.containerRef.current &&\r\n\t\t\t(!prevProps.embedConfig.accessToken ||\r\n\t\t\t\tthis.props.embedConfig.embedUrl !== prevProps.embedConfig.embedUrl)\r\n\t\t) {\r\n\t\t\tthis.embedEntity();\r\n\t\t}\r\n\r\n\t\t// Set new access token,\r\n\t\t// when access token is updated but embed Url is same\r\n\t\telse if (\r\n\t\t\tthis.props.embedConfig.accessToken !== prevProps.embedConfig.accessToken &&\r\n\t\t\tthis.props.embedConfig.embedUrl === prevProps.embedConfig.embedUrl &&\r\n\t\t\tthis.embed\r\n\t\t) {\r\n\t\t\tthis.embed.setAccessToken(this.props.embedConfig.accessToken)\r\n\t\t\t\t.catch((error) => {\r\n\t\t\t\t\tconsole.error(`setAccessToken error: ${error}`);\r\n\t\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Sets all event handlers from the props on the embedded entity\r\n\t * \r\n\t * @param embed Embedded object\r\n\t * @param eventHandlers Array of eventhandlers to be set on embedded entity\r\n\t * @returns void\r\n\t */\r\n\tprivate setEventHandlers(\r\n\t\tembed: Embed,\r\n\t\teventHandlerMap: Map<string, EventHandler>\r\n\t): void {\r\n\t\t// Get string representation of eventHandlerMap\r\n\t\tconst eventHandlerMapString = stringifyMap(this.props.eventHandlers);\r\n\r\n\t\t// Check if event handler map changed\r\n\t\tif (this.prevEventHandlerMapString === eventHandlerMapString) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Update prev string representation of event handler map\r\n\t\tthis.prevEventHandlerMapString = eventHandlerMapString;\r\n\r\n\t\t// List of allowed events\r\n\t\tlet allowedEvents = Embed.allowedEvents;\r\n\r\n\t\tconst entityType = embed.embedtype;\r\n\r\n\t\t// Append entity specific events\r\n\t\tswitch (entityType) {\r\n\t\t\tcase EmbedType.Report:\r\n\t\t\t\tallowedEvents = [...allowedEvents, ...Report.allowedEvents]\r\n\t\t\t\tbreak;\r\n\t\t\tcase EmbedType.Dashboard:\r\n\t\t\t\tallowedEvents = [...allowedEvents, ...Dashboard.allowedEvents]\r\n\t\t\t\tbreak;\r\n\t\t\tcase EmbedType.Tile:\r\n\t\t\t\tallowedEvents = [...allowedEvents, ...Tile.allowedEvents]\r\n\t\t\t\tbreak;\r\n\t\t\tcase EmbedType.Qna:\r\n\t\t\t\tallowedEvents = [...allowedEvents, ...Qna.allowedEvents]\r\n\t\t\t\tbreak;\r\n\t\t\tcase EmbedType.Visual:\r\n\t\t\t\tallowedEvents = [...allowedEvents, ...Visual.allowedEvents]\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tconsole.error(`Invalid embed type ${entityType}`);\r\n\t\t}\r\n\r\n\t\t// Holds list of events which are not allowed\r\n\t\tconst invalidEvents: Array<string> = [];\r\n\r\n\t\t// Apply all provided event handlers\r\n\t\teventHandlerMap.forEach((eventHandlerMethod, eventName) => {\r\n\t\t\t// Check if this event is allowed\r\n\t\t\tif (allowedEvents.includes(eventName)) {\r\n\r\n\t\t\t\t// Removes event handler for this event\r\n\t\t\t\tembed.off(eventName);\r\n\r\n\t\t\t\t// Event handler is effectively removed for this event when eventHandlerMethod is null\r\n\t\t\t\tif (eventHandlerMethod) {\r\n\r\n\t\t\t\t\t// Set single event handler\r\n\t\t\t\t\tembed.on(eventName, (event: service.ICustomEvent<any>): void => {\r\n\t\t\t\t\t\teventHandlerMethod(event, this.embed);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\r\n\t\t\t\t// Add this event name to the list of invalid events\r\n\t\t\t\tinvalidEvents.push(eventName);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Handle invalid events\r\n\t\tif (invalidEvents.length) {\r\n\t\t\tconsole.error(`Following events are invalid: ${invalidEvents.join(',')}`);\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the embedded object via _getEmbed_ callback method provided in props\r\n\t * \r\n\t * @returns void\r\n\t */\r\n\tprivate invokeGetEmbedCallback(): void {\r\n\t\tif (this.props.getEmbeddedComponent && this.embed) {\r\n\t\t\tthis.props.getEmbeddedComponent(this.embed);\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Update settings from props of the embedded artifact\r\n\t * \r\n\t * @returns void\r\n\t */\r\n\tprivate async updateSettings(): Promise<void> {\r\n\t\tif (!this.embed || !this.props.embedConfig.settings) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tswitch (this.props.embedConfig.type) {\r\n\t\t\tcase EmbedType.Report: {\r\n\t\t\t\t// Typecasted to IEmbedSettings as props.embedConfig.settings can be ISettings via IQnaEmbedConfiguration\r\n\t\t\t\tconst settings = this.props.embedConfig.settings as IEmbedSettings;\r\n\r\n\t\t\t\ttry {\r\n\t\t\t\t\t// Upcast to Report and call updateSettings\r\n\t\t\t\t\tawait (this.embed as Report).updateSettings(settings);\r\n\t\t\t\t} catch (error) {\r\n\t\t\t\t\tconsole.error(`Error in method updateSettings: ${error}`);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase EmbedType.Dashboard:\r\n\t\t\tcase EmbedType.Tile:\r\n\t\t\tcase EmbedType.Qna:\r\n\t\t\tcase EmbedType.Visual:\r\n\t\t\t\t// updateSettings not applicable for these embedding types\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tconsole.error(`Invalid embed type ${this.props.embedConfig.type}`);\r\n\t\t}\r\n\t};\r\n}\r\n","// Copyright (c) Microsoft Corporation.\r\n// Licensed under the MIT License.\r\n\r\nimport { EmbedProps } from \"./PowerBIEmbed\";\r\n\r\n/**\r\n * Get JSON string representation of the given map.\r\n * \r\n * @param map Map of event and corresponding handler method\r\n * \r\n * For example:\r\n * Input:\r\n * ```\r\n *  Map([\r\n\t\t['loaded', null],\r\n\t\t['rendered', function () { console.log('Rendered'); }]\r\n\t]);\r\n * ```\r\n * Output:\r\n * ```\r\n * `[[\"loaded\",\"\"],[\"rendered\",\"function () { console.log('Rendered'); }\"]]`\r\n * ```\r\n */\r\nexport function stringifyMap(map: EmbedProps['eventHandlers']): string {\r\n\r\n\t// Return empty string for empty/null map\r\n\tif (!map) {\r\n\t\treturn '';\r\n\t}\r\n\r\n\t// Get entries of map as array\r\n\tconst mapEntries = Array.from(map);\r\n\t\r\n\t// Return JSON string\r\n\treturn JSON.stringify(mapEntries.map((mapEntry) => {\r\n\t\t\r\n\t\t// Convert event handler method to a string containing its source code for comparison\r\n\t\treturn [\r\n\t\t\tmapEntry[0], \r\n\t\t\tmapEntry[1] ? mapEntry[1].toString() : ''\r\n\t\t]; \r\n\t}));\r\n};"],"sourceRoot":""}