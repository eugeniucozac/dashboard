{"ast":null,"code":"import chroma from 'chroma-js';\nimport config from 'config';\nimport isNumber from 'lodash/isNumber';\nimport randomcolor from 'randomcolor';\nvar utilsColor = {\n  /**\r\n   * Return an array of colors, or a single color from that array if in index is provided.\r\n   * @param {number} [count=128] The number of color to create in the array.\r\n   * @param {Boolean} trim Trim x colors from each end of the array.\r\n   * @param {number|null} index The specific index to return.\r\n   * @param {Array} colors The array of colors from which to create the color scale.\r\n   * @param {Boolean} correctLightness To apply or not Chroma correctLightness.\r\n   * @param {Boolean} bezierInterpolation To apply or not Chroma bezierInterpolation.\r\n   * @param {string} mode Color mode to use.\r\n   * @returns {(string|Array)}\r\n   */\n  scale: function scale() {\n    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 128;\n    var trim = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var index = arguments.length > 2 ? arguments[2] : undefined;\n    var colors = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : config.ui.chart.colours.default;\n    var correctLightness = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    var bezierInterpolation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    var mode = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'lab';\n    var colorCount = parseInt(count);\n    var colorScale;\n    var colorArray;\n    var hasIndex = isNumber(index) && index >= 0;\n    var colorIndex = hasIndex && parseInt(index);\n\n    if (bezierInterpolation) {\n      colorScale = chroma.bezier(colors).scale();\n    } else {\n      colorScale = chroma.scale(colors);\n    } // apply mode and correct lightness\n\n\n    colorScale = colorScale.mode(mode).correctLightness(correctLightness);\n\n    if (trim && colorCount <= 6) {\n      colorArray = colorScale.colors(colorCount + 10).slice(6, -4);\n    } else if (trim && colorCount <= 8) {\n      colorArray = colorScale.colors(colorCount + 8).slice(5, -3);\n    } else if (trim && colorCount <= 12) {\n      colorArray = colorScale.colors(colorCount + 8).slice(5, -3);\n    } else if (trim && colorCount <= 24) {\n      colorArray = colorScale.colors(colorCount + 8).slice(5, -3);\n    } else if (trim) {\n      colorArray = colorScale.colors(colorCount + 8).slice(5, -3);\n    } else {\n      colorArray = colorScale.colors(colorCount);\n    }\n\n    return hasIndex ? colorArray[colorIndex >= colorCount ? colorCount : colorIndex] : colorArray;\n  },\n\n  /**\r\n   * Return a single color from the string supplied.\r\n   * @param {string} seed An integer or string which when passed will cause randomColor to return the same color each time.\r\n   * @param {string} luminosity Controls the luminosity of the generated color. You can specify a string containing bright, light or dark\r\n   * @returns {string}\r\n   */\n  random: function random(seed) {\n    var luminosity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'dark';\n    return randomcolor({\n      seed: seed,\n      luminosity: luminosity\n    });\n  },\n\n  /**\r\n   * Return either white or black (text) to ensure a minimum contrast with another color (bg)\r\n   * @param {color} seed A color string (hex, rgb, hsl...) string which when passed will cause randomColor to return the same color each time.\r\n   * @param {diff} luminosity Controls the luminosity of the generated color. You can specify a string containing bright, light or dark\r\n   * @returns {string}\r\n   */\n  contrast: function contrast(color) {\n    var diff = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.4;\n    return chroma(color).luminance() >= diff ? 'black' : 'white';\n  }\n};\nexport default utilsColor;","map":{"version":3,"sources":["E:/MPHASIS/claims-page/Mphasis-Edge/src/utils/color/color.js"],"names":["chroma","config","isNumber","randomcolor","utilsColor","scale","count","trim","index","colors","ui","chart","colours","default","correctLightness","bezierInterpolation","mode","colorCount","parseInt","colorScale","colorArray","hasIndex","colorIndex","bezier","slice","random","seed","luminosity","contrast","color","diff","luminance"],"mappings":"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","sourcesContent":["import chroma from 'chroma-js';\r\nimport config from 'config';\r\nimport isNumber from 'lodash/isNumber';\r\nimport randomcolor from 'randomcolor';\r\n\r\nconst utilsColor = {\r\n  /**\r\n   * Return an array of colors, or a single color from that array if in index is provided.\r\n   * @param {number} [count=128] The number of color to create in the array.\r\n   * @param {Boolean} trim Trim x colors from each end of the array.\r\n   * @param {number|null} index The specific index to return.\r\n   * @param {Array} colors The array of colors from which to create the color scale.\r\n   * @param {Boolean} correctLightness To apply or not Chroma correctLightness.\r\n   * @param {Boolean} bezierInterpolation To apply or not Chroma bezierInterpolation.\r\n   * @param {string} mode Color mode to use.\r\n   * @returns {(string|Array)}\r\n   */\r\n  scale: (\r\n    count = 128,\r\n    trim = true,\r\n    index,\r\n    colors = config.ui.chart.colours.default,\r\n    correctLightness = false,\r\n    bezierInterpolation = true,\r\n    mode = 'lab'\r\n  ) => {\r\n    const colorCount = parseInt(count);\r\n    let colorScale;\r\n    let colorArray;\r\n    const hasIndex = isNumber(index) && index >= 0;\r\n    const colorIndex = hasIndex && parseInt(index);\r\n\r\n    if (bezierInterpolation) {\r\n      colorScale = chroma.bezier(colors).scale();\r\n    } else {\r\n      colorScale = chroma.scale(colors);\r\n    }\r\n\r\n    // apply mode and correct lightness\r\n    colorScale = colorScale.mode(mode).correctLightness(correctLightness);\r\n\r\n    if (trim && colorCount <= 6) {\r\n      colorArray = colorScale.colors(colorCount + 10).slice(6, -4);\r\n    } else if (trim && colorCount <= 8) {\r\n      colorArray = colorScale.colors(colorCount + 8).slice(5, -3);\r\n    } else if (trim && colorCount <= 12) {\r\n      colorArray = colorScale.colors(colorCount + 8).slice(5, -3);\r\n    } else if (trim && colorCount <= 24) {\r\n      colorArray = colorScale.colors(colorCount + 8).slice(5, -3);\r\n    } else if (trim) {\r\n      colorArray = colorScale.colors(colorCount + 8).slice(5, -3);\r\n    } else {\r\n      colorArray = colorScale.colors(colorCount);\r\n    }\r\n\r\n    return hasIndex ? colorArray[colorIndex >= colorCount ? colorCount : colorIndex] : colorArray;\r\n  },\r\n\r\n  /**\r\n   * Return a single color from the string supplied.\r\n   * @param {string} seed An integer or string which when passed will cause randomColor to return the same color each time.\r\n   * @param {string} luminosity Controls the luminosity of the generated color. You can specify a string containing bright, light or dark\r\n   * @returns {string}\r\n   */\r\n  random: (seed, luminosity = 'dark') => {\r\n    return randomcolor({ seed, luminosity });\r\n  },\r\n\r\n  /**\r\n   * Return either white or black (text) to ensure a minimum contrast with another color (bg)\r\n   * @param {color} seed A color string (hex, rgb, hsl...) string which when passed will cause randomColor to return the same color each time.\r\n   * @param {diff} luminosity Controls the luminosity of the generated color. You can specify a string containing bright, light or dark\r\n   * @returns {string}\r\n   */\r\n  contrast: (color, diff = 0.4) => {\r\n    return chroma(color).luminance() >= diff ? 'black' : 'white';\r\n  },\r\n};\r\n\r\nexport default utilsColor;\r\n"]},"metadata":{},"sourceType":"module"}