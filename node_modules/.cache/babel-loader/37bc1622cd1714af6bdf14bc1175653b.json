{"ast":null,"code":"import _objectSpread from \"E:/MPHASIS/claims-page/Mphasis-Edge/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport get from 'lodash/get';\nimport orderBy from 'lodash/orderBy'; // app\n\nimport { addLoader, authLogout, enqueueNotification, hideModal, removeLoader } from 'stores';\nimport * as utils from 'utils';\nexport var postNewLocationGroup = function postNewLocationGroup() {\n  return function (dispatch, getState) {\n    // prettier-ignore\n    var _getState = getState(),\n        user = _getState.user,\n        endpoint = _getState.config.vars.endpoint;\n\n    var auth = user.auth;\n    var defaultError = {\n      file: 'stores/location.actions'\n    };\n    var state = getState();\n    var placementId = get(state, 'placement.selected.id');\n    var locationsUploaded = get(state, 'location.locationsUploaded', []);\n    dispatch({\n      type: 'LOCATION_POST_NEW_GROUP',\n      payload: locationsUploaded\n    });\n    dispatch(addLoader('postNewLocationGroup'));\n    if (!placementId) defaultError.title = 'Missing placement selected ID';\n    if (!user.emailId) defaultError.title = 'Missing user email ID';\n    if (!auth.accessToken) defaultError.title = 'Missing user access token';\n\n    if (!placementId || !user.emailId || !auth.accessToken) {\n      dispatch({\n        type: 'LOCATION_POST_NEW_GROUP_FAILURE',\n        payload: defaultError\n      });\n      dispatch(removeLoader('postNewLocationGroup'));\n      return;\n    }\n\n    var body = {\n      placementId: placementId,\n      uploaderEmail: user.emailId,\n      locations: locationsUploaded\n    };\n    return utils.api.post({\n      token: auth.accessToken,\n      endpoint: endpoint.location,\n      path: 'api/locations',\n      data: body\n    }).then(function (response) {\n      return utils.api.handleResponse(response);\n    }).then(function (json) {\n      return utils.api.handleData(json);\n    }).then(function (data) {\n      dispatch({\n        type: 'LOCATION_POST_NEW_GROUP_SUCCESS',\n        payload: data\n      });\n      dispatch(hideModal());\n      dispatch(getLocationGroupsForPlacement(placementId));\n      dispatch(removeLoader('postNewLocationGroup'));\n      dispatch(enqueueNotification('notification.location.success', 'success'));\n    }).catch(function (err) {\n      var errorParams = _objectSpread(_objectSpread({}, defaultError), {}, {\n        title: 'API post error (location)'\n      });\n\n      dispatch({\n        type: 'LOCATION_POST_NEW_GROUP_FAILURE',\n        payload: err\n      });\n      utils.api.handleError(err, errorParams);\n      utils.api.handleUnauthorized(err, dispatch, authLogout);\n      dispatch(hideModal());\n      dispatch(removeLoader('postNewLocationGroup'));\n      dispatch(enqueueNotification('notification.location.fail', 'error'));\n      return err;\n    }).finally(function () {\n      dispatch({\n        type: 'LOCATION_SET_UPLOAD_WIZARD_HEADER_MAP_RESET'\n      });\n    });\n  };\n};\nexport var getLocationGroupsForPlacement = function getLocationGroupsForPlacement(placementId, showLoader) {\n  return function (dispatch, getState) {\n    // prettier-ignore\n    var _getState2 = getState(),\n        auth = _getState2.user.auth,\n        endpoint = _getState2.config.vars.endpoint;\n\n    var defaultError = {\n      file: 'stores/location.actions'\n    };\n    dispatch({\n      type: 'LOCATION_GET_PLACEMENT_GROUPS',\n      payload: placementId\n    });\n\n    if (showLoader) {\n      dispatch(addLoader('getLocationGroupsForPlacement'));\n    }\n\n    if (!placementId) defaultError.title = 'Missing placement selected ID';\n    if (!auth.accessToken) defaultError.title = 'Missing user access token';\n\n    if (!placementId || !auth.accessToken) {\n      dispatch({\n        type: 'LOCATION_GET_PLACEMENT_GROUPS_FAILURE',\n        payload: defaultError\n      });\n      return;\n    }\n\n    return utils.api.get({\n      token: auth.accessToken,\n      endpoint: endpoint.location,\n      path: \"api/locations/\".concat(placementId)\n    }).then(function (response) {\n      return utils.api.handleResponse(response);\n    }).then(function (json) {\n      return utils.api.handleData(json);\n    }).then(function (data) {\n      dispatch({\n        type: 'LOCATION_GET_PLACEMENT_GROUPS_SUCCESS',\n        payload: data\n      });\n\n      if (showLoader) {\n        dispatch(removeLoader('getLocationGroupsForPlacement'));\n      }\n\n      dispatch(setLocationGroups(placementId, data));\n    }).catch(function (err) {\n      var errorParams = _objectSpread(_objectSpread({}, defaultError), {}, {\n        title: 'API get error (locations)'\n      });\n\n      dispatch({\n        type: 'LOCATION_GET_PLACEMENT_GROUPS_FAILURE',\n        payload: err\n      });\n\n      if (showLoader) {\n        dispatch(removeLoader('getLocationGroupsForPlacement'));\n      }\n\n      utils.api.handleError(err, errorParams);\n      utils.api.handleUnauthorized(err, dispatch, authLogout);\n      return err;\n    });\n  };\n};\nexport var setLocationGroups = function setLocationGroups(placementId, locationGroups) {\n  return function (dispatch, getState) {\n    var defaultError = {\n      file: 'stores/location.actions',\n      title: 'Too many attempts fetching geocoding for locations'\n    };\n    dispatch({\n      type: 'LOCATION_SET_GROUPS',\n      payload: {\n        id: placementId,\n        groups: locationGroups\n      }\n    });\n\n    if (!placementId) {\n      dispatch({\n        type: 'LOCATION_SET_GROUPS_FAILURE',\n        payload: _objectSpread(_objectSpread({}, defaultError), {}, {\n          title: 'Missing placement ID'\n        })\n      });\n      return;\n    }\n\n    if (locationGroups.length > 0) {\n      var state = getState();\n      var locationGroup = orderBy(locationGroups, ['id'], ['desc'])[0];\n      var geocodingComplete = locationGroup.geocodingStatus === 'COMPLETE';\n      var geocodingLocsTotal = locationGroup.locations.length;\n      var geocodingLocsCompleted = locationGroup.locations.filter(function (l) {\n        return Boolean(l.geocodeResult);\n      }).length; // if group geocoding status is COMPLETE, we assume it's correct and skip checking every locations\n\n      var geocodingLocsComplete = geocodingComplete || locationGroup.locations.every(function (l) {\n        return Boolean(l.geocodeResult);\n      });\n      var geocodingAttempts = get(state, 'location.geocoding.attempts', 0);\n      var maxAttempts = 18;\n      var delay = 600;\n      var increment = 1.2;\n      var timeout = geocodingAttempts * delay * increment; // if the server doesn't complete the geocoding, we stop after N attempts to avoid an infinite loop\n      // stop after 18 attempts (about 3 minutes using the formula above)\n\n      if (geocodingAttempts > maxAttempts) {\n        dispatch({\n          type: 'LOCATION_GEOCODING_UPDATE',\n          payload: {\n            status: false,\n            result: 'failed',\n            attempts: 0,\n            completed: geocodingLocsCompleted,\n            total: geocodingLocsTotal\n          }\n        });\n        dispatch({\n          type: 'LOCATION_SET_GROUPS_FAILURE',\n          payload: defaultError\n        });\n        dispatch(enqueueNotification('notification.geocoding.fail', 'warning'));\n        return;\n      } // the B/E flag isn't always correct (geocodingStatus === 'COMPLETE')\n      // sometimes it returns NOT_STARTED although all the locations are geocoded\n      // so we check and if one or the other seems complete, we're done\n      // if both are incomplete then we try again with another fetch\n\n\n      if (geocodingComplete || geocodingLocsComplete) {\n        if (geocodingAttempts > 0) {\n          dispatch(enqueueNotification('notification.geocoding.success', 'success'));\n        }\n\n        dispatch({\n          type: 'LOCATION_GEOCODING_UPDATE',\n          payload: {\n            status: false,\n            result: 'complete',\n            attempts: 0,\n            completed: geocodingLocsCompleted,\n            total: geocodingLocsTotal\n          }\n        });\n      } else {\n        dispatch({\n          type: 'LOCATION_GEOCODING_UPDATE',\n          payload: {\n            status: true,\n            result: 'inprogress',\n            attempts: geocodingAttempts + 1,\n            completed: geocodingLocsCompleted,\n            total: geocodingLocsTotal\n          }\n        }); // if geocoding isn't complete, we try to fetch again\n        // incremental delay between each requests to gradually reduce the number of attempts\n        // 1 = 600ms\n        // 2 = 1500ms\n        // 3 = 3750ms...\n\n        setTimeout(function () {\n          dispatch(getLocationGroupsForPlacement(placementId));\n        }, timeout);\n      }\n\n      dispatch(setMapLocations(placementId, locationGroup.locations));\n    } else {\n      dispatch(setMapLocations(placementId, []));\n    }\n  };\n};\nexport var setMapLocations = function setMapLocations(placementId, locations) {\n  return function (dispatch) {\n    dispatch({\n      type: 'LOCATION_SET_MAP_LOCATIONS',\n      payload: {\n        id: placementId,\n        locations: locations\n      }\n    });\n  };\n};\nexport var retryGeocoding = function retryGeocoding() {\n  return function (dispatch) {\n    dispatch({\n      type: 'LOCATION_GEOCODING_UPDATE',\n      payload: {\n        status: true,\n        result: null,\n        attempts: 1,\n        completed: 0,\n        total: 0\n      }\n    });\n  };\n};\nexport var resetLocations = function resetLocations() {\n  return function (dispatch) {\n    dispatch({\n      type: 'LOCATION_RESET'\n    });\n  };\n};","map":{"version":3,"sources":["E:/MPHASIS/claims-page/Mphasis-Edge/src/stores/location/location.actions.js"],"names":["get","orderBy","addLoader","authLogout","enqueueNotification","hideModal","removeLoader","utils","postNewLocationGroup","dispatch","getState","user","endpoint","config","vars","auth","defaultError","file","state","placementId","locationsUploaded","type","payload","title","emailId","accessToken","body","uploaderEmail","locations","api","post","token","location","path","data","then","response","handleResponse","json","handleData","getLocationGroupsForPlacement","catch","err","errorParams","handleError","handleUnauthorized","finally","showLoader","setLocationGroups","locationGroups","id","groups","length","locationGroup","geocodingComplete","geocodingStatus","geocodingLocsTotal","geocodingLocsCompleted","filter","l","Boolean","geocodeResult","geocodingLocsComplete","every","geocodingAttempts","maxAttempts","delay","increment","timeout","status","result","attempts","completed","total","setTimeout","setMapLocations","retryGeocoding","resetLocations"],"mappings":"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","sourcesContent":["import get from 'lodash/get';\r\nimport orderBy from 'lodash/orderBy';\r\n\r\n// app\r\nimport { addLoader, authLogout, enqueueNotification, hideModal, removeLoader } from 'stores';\r\nimport * as utils from 'utils';\r\n\r\nexport const postNewLocationGroup = () => (dispatch, getState) => {\r\n  // prettier-ignore\r\n  const { user, config: { vars: { endpoint }}} = getState();\r\n  const { auth } = user;\r\n\r\n  const defaultError = {\r\n    file: 'stores/location.actions',\r\n  };\r\n\r\n  const state = getState();\r\n  const placementId = get(state, 'placement.selected.id');\r\n  const locationsUploaded = get(state, 'location.locationsUploaded', []);\r\n\r\n  dispatch({ type: 'LOCATION_POST_NEW_GROUP', payload: locationsUploaded });\r\n  dispatch(addLoader('postNewLocationGroup'));\r\n\r\n  if (!placementId) defaultError.title = 'Missing placement selected ID';\r\n  if (!user.emailId) defaultError.title = 'Missing user email ID';\r\n  if (!auth.accessToken) defaultError.title = 'Missing user access token';\r\n\r\n  if (!placementId || !user.emailId || !auth.accessToken) {\r\n    dispatch({ type: 'LOCATION_POST_NEW_GROUP_FAILURE', payload: defaultError });\r\n    dispatch(removeLoader('postNewLocationGroup'));\r\n    return;\r\n  }\r\n\r\n  const body = {\r\n    placementId: placementId,\r\n    uploaderEmail: user.emailId,\r\n    locations: locationsUploaded,\r\n  };\r\n\r\n  return utils.api\r\n    .post({\r\n      token: auth.accessToken,\r\n      endpoint: endpoint.location,\r\n      path: 'api/locations',\r\n      data: body,\r\n    })\r\n    .then((response) => utils.api.handleResponse(response))\r\n    .then((json) => utils.api.handleData(json))\r\n    .then((data) => {\r\n      dispatch({ type: 'LOCATION_POST_NEW_GROUP_SUCCESS', payload: data });\r\n      dispatch(hideModal());\r\n      dispatch(getLocationGroupsForPlacement(placementId));\r\n      dispatch(removeLoader('postNewLocationGroup'));\r\n      dispatch(enqueueNotification('notification.location.success', 'success'));\r\n    })\r\n    .catch((err) => {\r\n      const errorParams = {\r\n        ...defaultError,\r\n        title: 'API post error (location)',\r\n      };\r\n\r\n      dispatch({ type: 'LOCATION_POST_NEW_GROUP_FAILURE', payload: err });\r\n      utils.api.handleError(err, errorParams);\r\n      utils.api.handleUnauthorized(err, dispatch, authLogout);\r\n      dispatch(hideModal());\r\n      dispatch(removeLoader('postNewLocationGroup'));\r\n      dispatch(enqueueNotification('notification.location.fail', 'error'));\r\n      return err;\r\n    })\r\n    .finally(() => {\r\n      dispatch({ type: 'LOCATION_SET_UPLOAD_WIZARD_HEADER_MAP_RESET' });\r\n    });\r\n};\r\n\r\nexport const getLocationGroupsForPlacement = (placementId, showLoader) => (dispatch, getState) => {\r\n  // prettier-ignore\r\n  const { user: { auth }, config: { vars: { endpoint }}} = getState();\r\n\r\n  const defaultError = {\r\n    file: 'stores/location.actions',\r\n  };\r\n\r\n  dispatch({ type: 'LOCATION_GET_PLACEMENT_GROUPS', payload: placementId });\r\n\r\n  if (showLoader) {\r\n    dispatch(addLoader('getLocationGroupsForPlacement'));\r\n  }\r\n\r\n  if (!placementId) defaultError.title = 'Missing placement selected ID';\r\n  if (!auth.accessToken) defaultError.title = 'Missing user access token';\r\n\r\n  if (!placementId || !auth.accessToken) {\r\n    dispatch({ type: 'LOCATION_GET_PLACEMENT_GROUPS_FAILURE', payload: defaultError });\r\n    return;\r\n  }\r\n\r\n  return utils.api\r\n    .get({\r\n      token: auth.accessToken,\r\n      endpoint: endpoint.location,\r\n      path: `api/locations/${placementId}`,\r\n    })\r\n    .then((response) => utils.api.handleResponse(response))\r\n    .then((json) => utils.api.handleData(json))\r\n    .then((data) => {\r\n      dispatch({ type: 'LOCATION_GET_PLACEMENT_GROUPS_SUCCESS', payload: data });\r\n\r\n      if (showLoader) {\r\n        dispatch(removeLoader('getLocationGroupsForPlacement'));\r\n      }\r\n\r\n      dispatch(setLocationGroups(placementId, data));\r\n    })\r\n    .catch((err) => {\r\n      const errorParams = {\r\n        ...defaultError,\r\n        title: 'API get error (locations)',\r\n      };\r\n\r\n      dispatch({ type: 'LOCATION_GET_PLACEMENT_GROUPS_FAILURE', payload: err });\r\n\r\n      if (showLoader) {\r\n        dispatch(removeLoader('getLocationGroupsForPlacement'));\r\n      }\r\n\r\n      utils.api.handleError(err, errorParams);\r\n      utils.api.handleUnauthorized(err, dispatch, authLogout);\r\n      return err;\r\n    });\r\n};\r\n\r\nexport const setLocationGroups = (placementId, locationGroups) => (dispatch, getState) => {\r\n  const defaultError = {\r\n    file: 'stores/location.actions',\r\n    title: 'Too many attempts fetching geocoding for locations',\r\n  };\r\n\r\n  dispatch({ type: 'LOCATION_SET_GROUPS', payload: { id: placementId, groups: locationGroups } });\r\n\r\n  if (!placementId) {\r\n    dispatch({ type: 'LOCATION_SET_GROUPS_FAILURE', payload: { ...defaultError, title: 'Missing placement ID' } });\r\n    return;\r\n  }\r\n\r\n  if (locationGroups.length > 0) {\r\n    const state = getState();\r\n    const locationGroup = orderBy(locationGroups, ['id'], ['desc'])[0];\r\n\r\n    const geocodingComplete = locationGroup.geocodingStatus === 'COMPLETE';\r\n    const geocodingLocsTotal = locationGroup.locations.length;\r\n    const geocodingLocsCompleted = locationGroup.locations.filter((l) => Boolean(l.geocodeResult)).length;\r\n\r\n    // if group geocoding status is COMPLETE, we assume it's correct and skip checking every locations\r\n    const geocodingLocsComplete = geocodingComplete || locationGroup.locations.every((l) => Boolean(l.geocodeResult));\r\n\r\n    const geocodingAttempts = get(state, 'location.geocoding.attempts', 0);\r\n    const maxAttempts = 18;\r\n    const delay = 600;\r\n    const increment = 1.2;\r\n    const timeout = geocodingAttempts * delay * increment;\r\n\r\n    // if the server doesn't complete the geocoding, we stop after N attempts to avoid an infinite loop\r\n    // stop after 18 attempts (about 3 minutes using the formula above)\r\n    if (geocodingAttempts > maxAttempts) {\r\n      dispatch({\r\n        type: 'LOCATION_GEOCODING_UPDATE',\r\n        payload: {\r\n          status: false,\r\n          result: 'failed',\r\n          attempts: 0,\r\n          completed: geocodingLocsCompleted,\r\n          total: geocodingLocsTotal,\r\n        },\r\n      });\r\n      dispatch({ type: 'LOCATION_SET_GROUPS_FAILURE', payload: defaultError });\r\n      dispatch(enqueueNotification('notification.geocoding.fail', 'warning'));\r\n      return;\r\n    }\r\n\r\n    // the B/E flag isn't always correct (geocodingStatus === 'COMPLETE')\r\n    // sometimes it returns NOT_STARTED although all the locations are geocoded\r\n    // so we check and if one or the other seems complete, we're done\r\n    // if both are incomplete then we try again with another fetch\r\n    if (geocodingComplete || geocodingLocsComplete) {\r\n      if (geocodingAttempts > 0) {\r\n        dispatch(enqueueNotification('notification.geocoding.success', 'success'));\r\n      }\r\n\r\n      dispatch({\r\n        type: 'LOCATION_GEOCODING_UPDATE',\r\n        payload: {\r\n          status: false,\r\n          result: 'complete',\r\n          attempts: 0,\r\n          completed: geocodingLocsCompleted,\r\n          total: geocodingLocsTotal,\r\n        },\r\n      });\r\n    } else {\r\n      dispatch({\r\n        type: 'LOCATION_GEOCODING_UPDATE',\r\n        payload: {\r\n          status: true,\r\n          result: 'inprogress',\r\n          attempts: geocodingAttempts + 1,\r\n          completed: geocodingLocsCompleted,\r\n          total: geocodingLocsTotal,\r\n        },\r\n      });\r\n\r\n      // if geocoding isn't complete, we try to fetch again\r\n      // incremental delay between each requests to gradually reduce the number of attempts\r\n      // 1 = 600ms\r\n      // 2 = 1500ms\r\n      // 3 = 3750ms...\r\n      setTimeout(() => {\r\n        dispatch(getLocationGroupsForPlacement(placementId));\r\n      }, timeout);\r\n    }\r\n\r\n    dispatch(setMapLocations(placementId, locationGroup.locations));\r\n  } else {\r\n    dispatch(setMapLocations(placementId, []));\r\n  }\r\n};\r\n\r\nexport const setMapLocations = (placementId, locations) => (dispatch) => {\r\n  dispatch({\r\n    type: 'LOCATION_SET_MAP_LOCATIONS',\r\n    payload: {\r\n      id: placementId,\r\n      locations,\r\n    },\r\n  });\r\n};\r\n\r\nexport const retryGeocoding = () => (dispatch) => {\r\n  dispatch({\r\n    type: 'LOCATION_GEOCODING_UPDATE',\r\n    payload: {\r\n      status: true,\r\n      result: null,\r\n      attempts: 1,\r\n      completed: 0,\r\n      total: 0,\r\n    },\r\n  });\r\n};\r\n\r\nexport const resetLocations = () => (dispatch) => {\r\n  dispatch({ type: 'LOCATION_RESET' });\r\n};\r\n"]},"metadata":{},"sourceType":"module"}