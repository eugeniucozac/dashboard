{"ast":null,"code":"import numbro from 'numbro';\nimport orderBy from 'lodash/orderBy';\nimport get from 'lodash/get'; // app\n\nimport * as utils from 'utils';\nvar utilsSort = {\n  array: function array(type, prop) {\n    var direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'asc';\n    var nullAtEnd = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var sortArray = arguments.length > 4 ? arguments[4] : undefined;\n    var dir = getDirection(direction);\n\n    switch (type) {\n      case 'date':\n        return date(prop, dir, nullAtEnd);\n\n      case 'numeric':\n        return numeric(prop, dir, nullAtEnd);\n\n      case 'boolean':\n        return boolean(prop, dir, nullAtEnd);\n\n      case 'customSort':\n        return customSort(prop, sortArray);\n\n      default:\n        return lexical(prop, dir, nullAtEnd);\n    }\n  },\n  arrayNestedPropertyValue: function arrayNestedPropertyValue(arr, prop) {\n    var dir = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'asc';\n    return orderBy(arr, [function (item) {\n      return get(item, prop);\n    }], [dir]);\n  }\n}; // customSort - based on sortArray values\n\nvar customSort = function customSort(prop, sortArray) {\n  if (utils.generic.isInvalidOrEmptyArray(sortArray)) return;\n  return function (a, b) {\n    return sortArray.indexOf(a[prop]) - sortArray.indexOf(b[prop]);\n  };\n};\n\nvar numeric = function numeric(prop) {\n  var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var nullAtEnd = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var dir = getDirection(direction);\n  return function (a, b) {\n    var aa = numbro.unformat(a[prop]);\n    var bb = numbro.unformat(b[prop]); // move falsy values (excl. zero (0)) at the end\n\n    var isFalsyA = aa === false || aa === null || aa === undefined || aa === '';\n    var isFalsyB = bb === false || bb === null || bb === undefined || bb === '';\n    var moveNullAtEnd = nullAtEnd ? isFalsyA - isFalsyB : false; // return moveNullAtEnd || +(aa > bb) * dir || -(aa < bb) * dir;\n\n    return moveNullAtEnd || dir * (aa - bb);\n  };\n};\n\nvar boolean = function boolean(prop) {\n  var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  // anything other than true is treated as false\n  // the order is: true > false AND/OR anything else...\n  var order = [true, false];\n  var dir = getDirection(direction);\n  return function (a, b) {\n    var aa = order.indexOf(a[prop]) >= 0 ? order.indexOf(a[prop]) : 1;\n    var bb = order.indexOf(b[prop]) >= 0 ? order.indexOf(b[prop]) : 1;\n    return dir * (aa - bb);\n  };\n};\n\nvar date = function date(prop) {\n  var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var nullAtEnd = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  // date values should be:\n  //    - timestamps: 1546300800000\n  //    - date string: '2010-12'\n  //    - date string: '2010-12-31'\n  //    - date string: '2010-12-31T23:59'\n  //    - date string: '2010-12-31T23:59:59'\n  var dir = getDirection(direction);\n  return function (a, b) {\n    var aTimestamp = new Date(a[prop]).getTime();\n    var bTimestamp = new Date(b[prop]).getTime(); // cast to 0 anything that's not a valid timestamp\n\n    var aa = Boolean(aTimestamp) ? aTimestamp : 0;\n    var bb = Boolean(bTimestamp) ? bTimestamp : 0; // move falsy values at the end\n    // negative timestamps are supported\n    // anything other than 0 and 1 is a valid timestamp\n    // 0 would be returned by new Date(false)\n    // 1 would be returned by new Date(true)\n    // even though both values are valid timestamp, we exclude them\n\n    var isFalsyA = !(aa < 0 || aa > 1);\n    var isFalsyB = !(bb < 0 || bb > 1);\n    var moveNullAtEnd = nullAtEnd ? isFalsyA - isFalsyB : false;\n    return moveNullAtEnd || dir * (aa - bb);\n  };\n};\n\nvar lexical = function lexical(prop) {\n  var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var nullAtEnd = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var dir = getDirection(direction);\n  return function (a, b) {\n    var aa = a[prop] ? a[prop].toString().toLowerCase().trim() : '';\n    var bb = b[prop] ? b[prop].toString().toLowerCase().trim() : '';\n    var isFalsyA = aa === null || aa === undefined || aa === '';\n    var isFalsyB = bb === null || bb === undefined || bb === '';\n\n    if (nullAtEnd) {\n      if (isFalsyA && isFalsyB) {\n        return 0;\n      } else if (isFalsyA) {\n        return dir ? 1 : -1;\n      } else if (isFalsyB) {\n        return dir ? -1 : 1;\n      }\n    }\n\n    if (bb > aa) return dir * -1;\n    if (bb < aa) return dir * 1;\n    return 0;\n  };\n};\n\nvar getDirection = function getDirection(dir) {\n  return dir === -1 || dir === 'desc' ? -1 : 1;\n};\n\nexport default utilsSort;","map":{"version":3,"sources":["E:/MPHASIS/claims-page/Mphasis-Edge/src/utils/sort/sort.js"],"names":["numbro","orderBy","get","utils","utilsSort","array","type","prop","direction","nullAtEnd","sortArray","dir","getDirection","date","numeric","boolean","customSort","lexical","arrayNestedPropertyValue","arr","item","generic","isInvalidOrEmptyArray","a","b","indexOf","aa","unformat","bb","isFalsyA","undefined","isFalsyB","moveNullAtEnd","order","aTimestamp","Date","getTime","bTimestamp","Boolean","toString","toLowerCase","trim"],"mappings":"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","sourcesContent":["import numbro from 'numbro';\r\nimport orderBy from 'lodash/orderBy';\r\nimport get from 'lodash/get';\r\n\r\n// app\r\nimport * as utils from 'utils';\r\n\r\nconst utilsSort = {\r\n  array: (type, prop, direction = 'asc', nullAtEnd = true, sortArray) => {\r\n    const dir = getDirection(direction);\r\n\r\n    switch (type) {\r\n      case 'date':\r\n        return date(prop, dir, nullAtEnd);\r\n      case 'numeric':\r\n        return numeric(prop, dir, nullAtEnd);\r\n      case 'boolean':\r\n        return boolean(prop, dir, nullAtEnd);\r\n      case 'customSort':\r\n        return customSort(prop, sortArray);\r\n      default:\r\n        return lexical(prop, dir, nullAtEnd);\r\n    }\r\n  },\r\n  arrayNestedPropertyValue: (arr, prop, dir = 'asc') => {\r\n    return orderBy(\r\n      arr,\r\n      [\r\n        function (item) {\r\n          return get(item, prop);\r\n        },\r\n      ],\r\n      [dir]\r\n    );\r\n  },\r\n};\r\n\r\n// customSort - based on sortArray values\r\nconst customSort = (prop, sortArray) => {\r\n  if (utils.generic.isInvalidOrEmptyArray(sortArray)) return;\r\n\r\n  return (a, b) => sortArray.indexOf(a[prop]) - sortArray.indexOf(b[prop]);\r\n};\r\nconst numeric = (prop, direction = 1, nullAtEnd = true) => {\r\n  const dir = getDirection(direction);\r\n\r\n  return (a, b) => {\r\n    const aa = numbro.unformat(a[prop]);\r\n    const bb = numbro.unformat(b[prop]);\r\n\r\n    // move falsy values (excl. zero (0)) at the end\r\n    const isFalsyA = aa === false || aa === null || aa === undefined || aa === '';\r\n    const isFalsyB = bb === false || bb === null || bb === undefined || bb === '';\r\n    const moveNullAtEnd = nullAtEnd ? isFalsyA - isFalsyB : false;\r\n\r\n    // return moveNullAtEnd || +(aa > bb) * dir || -(aa < bb) * dir;\r\n    return moveNullAtEnd || dir * (aa - bb);\r\n  };\r\n};\r\n\r\nconst boolean = (prop, direction = 1) => {\r\n  // anything other than true is treated as false\r\n  // the order is: true > false AND/OR anything else...\r\n  const order = [true, false];\r\n  const dir = getDirection(direction);\r\n\r\n  return (a, b) => {\r\n    const aa = order.indexOf(a[prop]) >= 0 ? order.indexOf(a[prop]) : 1;\r\n    const bb = order.indexOf(b[prop]) >= 0 ? order.indexOf(b[prop]) : 1;\r\n    return dir * (aa - bb);\r\n  };\r\n};\r\n\r\nconst date = (prop, direction = 1, nullAtEnd = true) => {\r\n  // date values should be:\r\n  //    - timestamps: 1546300800000\r\n  //    - date string: '2010-12'\r\n  //    - date string: '2010-12-31'\r\n  //    - date string: '2010-12-31T23:59'\r\n  //    - date string: '2010-12-31T23:59:59'\r\n  const dir = getDirection(direction);\r\n\r\n  return (a, b) => {\r\n    const aTimestamp = new Date(a[prop]).getTime();\r\n    const bTimestamp = new Date(b[prop]).getTime();\r\n\r\n    // cast to 0 anything that's not a valid timestamp\r\n    const aa = Boolean(aTimestamp) ? aTimestamp : 0;\r\n    const bb = Boolean(bTimestamp) ? bTimestamp : 0;\r\n\r\n    // move falsy values at the end\r\n    // negative timestamps are supported\r\n    // anything other than 0 and 1 is a valid timestamp\r\n    // 0 would be returned by new Date(false)\r\n    // 1 would be returned by new Date(true)\r\n    // even though both values are valid timestamp, we exclude them\r\n    const isFalsyA = !(aa < 0 || aa > 1);\r\n    const isFalsyB = !(bb < 0 || bb > 1);\r\n    const moveNullAtEnd = nullAtEnd ? isFalsyA - isFalsyB : false;\r\n\r\n    return moveNullAtEnd || dir * (aa - bb);\r\n  };\r\n};\r\n\r\nconst lexical = (prop, direction = 1, nullAtEnd = true) => {\r\n  const dir = getDirection(direction);\r\n\r\n  return (a, b) => {\r\n    const aa = a[prop] ? a[prop].toString().toLowerCase().trim() : '';\r\n    const bb = b[prop] ? b[prop].toString().toLowerCase().trim() : '';\r\n\r\n    const isFalsyA = aa === null || aa === undefined || aa === '';\r\n    const isFalsyB = bb === null || bb === undefined || bb === '';\r\n\r\n    if (nullAtEnd) {\r\n      if (isFalsyA && isFalsyB) {\r\n        return 0;\r\n      } else if (isFalsyA) {\r\n        return dir ? 1 : -1;\r\n      } else if (isFalsyB) {\r\n        return dir ? -1 : 1;\r\n      }\r\n    }\r\n\r\n    if (bb > aa) return dir * -1;\r\n    if (bb < aa) return dir * 1;\r\n    return 0;\r\n  };\r\n};\r\n\r\nconst getDirection = (dir) => {\r\n  return dir === -1 || dir === 'desc' ? -1 : 1;\r\n};\r\n\r\nexport default utilsSort;\r\n"]},"metadata":{},"sourceType":"module"}