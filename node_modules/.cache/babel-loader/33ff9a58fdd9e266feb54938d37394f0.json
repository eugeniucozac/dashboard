{"ast":null,"code":"import _objectSpread from \"E:/MPHASIS/claims-page/Mphasis-Edge/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _toConsumableArray from \"E:/MPHASIS/claims-page/Mphasis-Edge/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"E:/MPHASIS/claims-page/Mphasis-Edge/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"E:/MPHASIS/claims-page/Mphasis-Edge/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"E:/MPHASIS/claims-page/Mphasis-Edge/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"E:/MPHASIS/claims-page/Mphasis-Edge/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nvar _jsxFileName = \"E:\\\\MPHASIS\\\\claims-page\\\\Mphasis-Edge\\\\src\\\\modules\\\\ChartPremiumByMarket\\\\ChartPremiumByMarket.js\";\nimport React, { PureComponent } from 'react';\nimport PropTypes from 'prop-types';\nimport groupBy from 'lodash/groupBy';\nimport orderBy from 'lodash/orderBy';\nimport get from 'lodash/get'; // app\n\nimport { ChartPremium } from 'modules';\nimport * as utils from 'utils';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport var ChartPremiumByMarket = /*#__PURE__*/function (_PureComponent) {\n  _inherits(ChartPremiumByMarket, _PureComponent);\n\n  var _super = _createSuper(ChartPremiumByMarket);\n\n  function ChartPremiumByMarket() {\n    var _this;\n\n    _classCallCheck(this, ChartPremiumByMarket);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _this.getTableColumns = function (currency) {\n      return [{\n        id: 'name',\n        label: utils.string.t('app.market'),\n        sort: {\n          type: 'lexical',\n          direction: 'asc'\n        }\n      }, {\n        id: 'value',\n        label: utils.string.t('chart.legend.premium', {\n          currency: currency\n        }),\n        sort: {\n          type: 'numeric',\n          direction: 'desc'\n        }\n      }];\n    };\n\n    _this.filteredPlacements = function (placements) {\n      return placements.filter(function (placement) {\n        var year = _this.props.year;\n        var placementYear = utils.placement.getYear(placement); // Only keep placements for defined year\n\n        if (placementYear !== year) return false; // Only keep placements with premiums\n\n        return placement.policies.reduce(function (acc, policy) {\n          return acc || utils.policy.hasBoundPremium(policy);\n        }, false);\n      });\n    };\n\n    _this.formatData = function (placements) {\n      var data = placements.reduce(function (list, placement) {\n        var placementId = placement.id;\n        placement.policies.forEach(function (policy) {\n          var hasPremiums = utils.policy.hasBoundPremium(policy);\n          var policyPremiumByCurrency = utils.policy.getPremiumBySettlementCurrency(policy, true, true);\n          Object.keys(policyPremiumByCurrency).forEach(function (currency) {\n            var policySignedTotal = policy.markets.reduce(function (acc, market) {\n              return acc + utils.market.getLineSizeBySettlementCurrency(market, currency, true);\n            }, 0);\n\n            if (hasPremiums && utils.policy.isOriginGxb(policy)) {\n              policy.markets.forEach(function (market) {\n                var marketId = utils.market.getId(market);\n                var marketName = utils.market.getName(market);\n                var marketCurrency = utils.market.getSettlementIsoCode(market);\n                var marketPercentage = utils.market.getLineSizeBySettlementCurrency(market, currency, true);\n                var marketPremiumAmount = policyPremiumByCurrency[currency] * (marketPercentage / policySignedTotal);\n                var hasPercentage = Boolean(marketPercentage);\n                var isMatchingCurrency = Boolean(marketCurrency === currency);\n                var existingMarketIndex = list.findIndex(function (obj) {\n                  return obj.id === marketId && obj.currency === currency;\n                });\n                var marketAlreadyExist = existingMarketIndex >= 0;\n                var insureds = utils.placement.getInsureds(placement);\n                var listDatasets = marketAlreadyExist ? get(list, \"[\".concat(existingMarketIndex, \"].datasets\")) || [] : [];\n                var marketPremiumPrevious = listDatasets.reduce(function (acc, obj) {\n                  return acc + obj.value;\n                }, 0);\n                var marketPremiumTotal = marketPremiumPrevious + marketPremiumAmount; // standard list object\n                // if a market with the same ID already exists, only some of these properties will be used to update the current list object\n\n                var defaultListObj = {\n                  id: marketId,\n                  currency: currency,\n                  name: marketName,\n                  label: utils.string.t('format.currency', {\n                    value: {\n                      number: marketPremiumTotal,\n                      currency: currency\n                    }\n                  }),\n                  datasets: [{\n                    id: placementId,\n                    value: marketPremiumAmount,\n                    name: insureds,\n                    object: [market]\n                  }]\n                };\n\n                if (hasPercentage && isMatchingCurrency) {\n                  // if market already exists, we need to increment the \"label\" and\n                  // add the market in the datasets/objects\n                  if (marketAlreadyExist) {\n                    var updatedDatasets;\n                    var placementCurrentIndex = list[existingMarketIndex].datasets.findIndex(function (obj) {\n                      return obj.id === placementId;\n                    });\n                    var placementAlreadyExist = placementCurrentIndex >= 0;\n                    var placementCurrentObj = list[existingMarketIndex].datasets[placementCurrentIndex];\n                    var placementCurrentPremium = placementAlreadyExist ? placementCurrentObj.value : 0; // if a placement already exists, we need to increment the \"value\" premium and add the market object in the \"object\" array\n                    // if not, we simply add the dataset from defaultListObj to the datasets array\n\n                    if (placementAlreadyExist) {\n                      updatedDatasets = list[existingMarketIndex].datasets.map(function (set) {\n                        if (set.id === placementId) {\n                          set.value = placementCurrentPremium + marketPremiumAmount;\n                          set.object = [].concat(_toConsumableArray(set.object), _toConsumableArray(defaultListObj.datasets[0].object));\n                        }\n\n                        return set;\n                      });\n                    } else {\n                      updatedDatasets = [].concat(_toConsumableArray(list[existingMarketIndex].datasets), _toConsumableArray(defaultListObj.datasets));\n                    }\n\n                    list[existingMarketIndex] = _objectSpread(_objectSpread({}, list[existingMarketIndex]), {}, {\n                      label: defaultListObj.label,\n                      datasets: _toConsumableArray(updatedDatasets)\n                    });\n                  } else {\n                    list = [].concat(_toConsumableArray(list), [defaultListObj]);\n                  }\n                }\n\n                return list;\n              });\n            }\n\n            return list;\n          });\n        });\n        return list;\n      }, []);\n      var grouped = groupBy(data, function (item) {\n        return item.currency;\n      });\n      return Object.keys(grouped).map(function (currency) {\n        return {\n          currency: currency,\n          data: grouped[currency],\n          columns: _this.getTableColumns(currency)\n        };\n      });\n    };\n\n    return _this;\n  }\n\n  _createClass(ChartPremiumByMarket, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          placements = _this$props.placements,\n          year = _this$props.year; // abort\n\n      if (!placements) return null;\n      var filteredPlacements = this.filteredPlacements(placements);\n      var dataByCurrency = orderBy(this.formatData(filteredPlacements), 'currency');\n      return /*#__PURE__*/_jsxDEV(ChartPremium, {\n        id: \"byMarket\",\n        year: year,\n        dataByCurrency: dataByCurrency,\n        table: true\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 156,\n        columnNumber: 12\n      }, this);\n    }\n  }]);\n\n  return ChartPremiumByMarket;\n}(PureComponent);\nChartPremiumByMarket.propTypes = {\n  placements: PropTypes.array.isRequired,\n  year: PropTypes.number\n};\nexport default ChartPremiumByMarket;","map":{"version":3,"sources":["E:/MPHASIS/claims-page/Mphasis-Edge/src/modules/ChartPremiumByMarket/ChartPremiumByMarket.js"],"names":["React","PureComponent","PropTypes","groupBy","orderBy","get","ChartPremium","utils","ChartPremiumByMarket","getTableColumns","currency","id","label","string","t","sort","type","direction","filteredPlacements","placements","filter","placement","year","props","placementYear","getYear","policies","reduce","acc","policy","hasBoundPremium","formatData","data","list","placementId","forEach","hasPremiums","policyPremiumByCurrency","getPremiumBySettlementCurrency","Object","keys","policySignedTotal","markets","market","getLineSizeBySettlementCurrency","isOriginGxb","marketId","getId","marketName","getName","marketCurrency","getSettlementIsoCode","marketPercentage","marketPremiumAmount","hasPercentage","Boolean","isMatchingCurrency","existingMarketIndex","findIndex","obj","marketAlreadyExist","insureds","getInsureds","listDatasets","marketPremiumPrevious","value","marketPremiumTotal","defaultListObj","name","number","datasets","object","updatedDatasets","placementCurrentIndex","placementAlreadyExist","placementCurrentObj","placementCurrentPremium","map","set","grouped","item","columns","dataByCurrency","propTypes","array","isRequired"],"mappings":"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","sourcesContent":["import React, { PureComponent } from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport groupBy from 'lodash/groupBy';\r\nimport orderBy from 'lodash/orderBy';\r\nimport get from 'lodash/get';\r\n\r\n// app\r\nimport { ChartPremium } from 'modules';\r\nimport * as utils from 'utils';\r\n\r\nexport class ChartPremiumByMarket extends PureComponent {\r\n  static propTypes = {\r\n    placements: PropTypes.array.isRequired,\r\n    year: PropTypes.number,\r\n  };\r\n\r\n  getTableColumns = (currency) => [\r\n    {\r\n      id: 'name',\r\n      label: utils.string.t('app.market'),\r\n      sort: { type: 'lexical', direction: 'asc' },\r\n    },\r\n    {\r\n      id: 'value',\r\n      label: utils.string.t('chart.legend.premium', { currency }),\r\n      sort: { type: 'numeric', direction: 'desc' },\r\n    },\r\n  ];\r\n\r\n  filteredPlacements = (placements) => {\r\n    return placements.filter((placement) => {\r\n      const { year } = this.props;\r\n      const placementYear = utils.placement.getYear(placement);\r\n\r\n      // Only keep placements for defined year\r\n      if (placementYear !== year) return false;\r\n\r\n      // Only keep placements with premiums\r\n      return placement.policies.reduce((acc, policy) => {\r\n        return acc || utils.policy.hasBoundPremium(policy);\r\n      }, false);\r\n    });\r\n  };\r\n\r\n  formatData = (placements) => {\r\n    const data = placements.reduce((list, placement) => {\r\n      const placementId = placement.id;\r\n\r\n      placement.policies.forEach((policy) => {\r\n        const hasPremiums = utils.policy.hasBoundPremium(policy);\r\n        const policyPremiumByCurrency = utils.policy.getPremiumBySettlementCurrency(policy, true, true);\r\n\r\n        Object.keys(policyPremiumByCurrency).forEach((currency) => {\r\n          const policySignedTotal = policy.markets.reduce((acc, market) => {\r\n            return acc + utils.market.getLineSizeBySettlementCurrency(market, currency, true);\r\n          }, 0);\r\n\r\n          if (hasPremiums && utils.policy.isOriginGxb(policy)) {\r\n            policy.markets.forEach((market) => {\r\n              const marketId = utils.market.getId(market);\r\n              const marketName = utils.market.getName(market);\r\n              const marketCurrency = utils.market.getSettlementIsoCode(market);\r\n              const marketPercentage = utils.market.getLineSizeBySettlementCurrency(market, currency, true);\r\n              const marketPremiumAmount = policyPremiumByCurrency[currency] * (marketPercentage / policySignedTotal);\r\n              const hasPercentage = Boolean(marketPercentage);\r\n              const isMatchingCurrency = Boolean(marketCurrency === currency);\r\n              const existingMarketIndex = list.findIndex((obj) => obj.id === marketId && obj.currency === currency);\r\n              const marketAlreadyExist = existingMarketIndex >= 0;\r\n              const insureds = utils.placement.getInsureds(placement);\r\n\r\n              const listDatasets = marketAlreadyExist ? get(list, `[${existingMarketIndex}].datasets`) || [] : [];\r\n              const marketPremiumPrevious = listDatasets.reduce((acc, obj) => acc + obj.value, 0);\r\n              const marketPremiumTotal = marketPremiumPrevious + marketPremiumAmount;\r\n\r\n              // standard list object\r\n              // if a market with the same ID already exists, only some of these properties will be used to update the current list object\r\n              const defaultListObj = {\r\n                id: marketId,\r\n                currency,\r\n                name: marketName,\r\n                label: utils.string.t('format.currency', { value: { number: marketPremiumTotal, currency } }),\r\n                datasets: [\r\n                  {\r\n                    id: placementId,\r\n                    value: marketPremiumAmount,\r\n                    name: insureds,\r\n                    object: [market],\r\n                  },\r\n                ],\r\n              };\r\n\r\n              if (hasPercentage && isMatchingCurrency) {\r\n                // if market already exists, we need to increment the \"label\" and\r\n                // add the market in the datasets/objects\r\n                if (marketAlreadyExist) {\r\n                  let updatedDatasets;\r\n                  const placementCurrentIndex = list[existingMarketIndex].datasets.findIndex((obj) => obj.id === placementId);\r\n                  const placementAlreadyExist = placementCurrentIndex >= 0;\r\n                  const placementCurrentObj = list[existingMarketIndex].datasets[placementCurrentIndex];\r\n                  const placementCurrentPremium = placementAlreadyExist ? placementCurrentObj.value : 0;\r\n\r\n                  // if a placement already exists, we need to increment the \"value\" premium and add the market object in the \"object\" array\r\n                  // if not, we simply add the dataset from defaultListObj to the datasets array\r\n                  if (placementAlreadyExist) {\r\n                    updatedDatasets = list[existingMarketIndex].datasets.map((set) => {\r\n                      if (set.id === placementId) {\r\n                        set.value = placementCurrentPremium + marketPremiumAmount;\r\n                        set.object = [...set.object, ...defaultListObj.datasets[0].object];\r\n                      }\r\n\r\n                      return set;\r\n                    });\r\n                  } else {\r\n                    updatedDatasets = [...list[existingMarketIndex].datasets, ...defaultListObj.datasets];\r\n                  }\r\n\r\n                  list[existingMarketIndex] = {\r\n                    ...list[existingMarketIndex],\r\n                    label: defaultListObj.label,\r\n                    datasets: [...updatedDatasets],\r\n                  };\r\n                } else {\r\n                  list = [...list, defaultListObj];\r\n                }\r\n              }\r\n\r\n              return list;\r\n            });\r\n          }\r\n\r\n          return list;\r\n        });\r\n      });\r\n\r\n      return list;\r\n    }, []);\r\n\r\n    const grouped = groupBy(data, (item) => item.currency);\r\n\r\n    return Object.keys(grouped).map((currency) => ({\r\n      currency,\r\n      data: grouped[currency],\r\n      columns: this.getTableColumns(currency),\r\n    }));\r\n  };\r\n\r\n  render() {\r\n    const { placements, year } = this.props;\r\n\r\n    // abort\r\n    if (!placements) return null;\r\n\r\n    const filteredPlacements = this.filteredPlacements(placements);\r\n    const dataByCurrency = orderBy(this.formatData(filteredPlacements), 'currency');\r\n\r\n    return <ChartPremium id=\"byMarket\" year={year} dataByCurrency={dataByCurrency} table />;\r\n  }\r\n}\r\n\r\nexport default ChartPremiumByMarket;\r\n"]},"metadata":{},"sourceType":"module"}