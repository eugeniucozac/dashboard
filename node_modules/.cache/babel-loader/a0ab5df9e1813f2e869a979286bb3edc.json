{"ast":null,"code":"import _slicedToArray from \"E:/MPHASIS/claims-page/Mphasis-Edge/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _typeof from \"E:/MPHASIS/claims-page/Mphasis-Edge/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/typeof\";\nimport mapboxgl from 'mapbox-gl';\nimport isEqual from 'lodash/isEqual';\nimport get from 'lodash/get'; // app\n\nimport * as utils from 'utils';\nimport config from 'config';\nvar utilsMap = {\n  visibility: {\n    visible: 'visible',\n    none: 'none'\n  },\n  setMarkers: function setMarkers(mapInstance, locations) {\n    var markers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    if (!mapInstance || !locations || !utils.generic.isValidArray(markers)) return;\n    var markersArray = [];\n    utilsMap.parseLocations(locations).forEach(function (location) {\n      var bespokeColor = get(location, 'properties.backgroundColor[0]');\n      var color = bespokeColor || config.mapbox.marker.color[location.active ? 'active' : 'default'];\n      var marker = new mapboxgl.Marker({\n        color: color\n      }).setLngLat([location.lng, location.lat]);\n      var markerExists = markers.find(function (m) {\n        return isEqual(m.getLngLat(), marker.getLngLat());\n      });\n      if (markerExists) return; // adding original location object (id, lat, lng, etc...) to the marker\n\n      marker.location = location;\n\n      try {\n        marker.addTo(mapInstance);\n      } catch (_unused) {}\n\n      markersArray.push(marker);\n    });\n    return markersArray;\n  },\n  parseLocations: function parseLocations(locations) {\n    if (!utils.generic.isValidArray(locations, true)) return [];\n    return locations.filter(function (location) {\n      return location && location.locationsFound > 0;\n    }).sort(function (a, b) {\n      if (!a || !b) return false;\n      if (!a.lat && a.lat !== 0 || !b.lat && b.lat !== 0) return false;\n      return b.lat - a.lat;\n    });\n  },\n  addDefaultLayers: function addDefaultLayers(map, layers) {\n    if (!map || !layers || _typeof(layers) !== 'object') return map;\n    Object.values(layers).forEach(function (lg) {\n      lg.config.forEach(function (c) {\n        if (utils.generic.isFunction(map.addLayer) && !map.getLayer(c.id)) {\n          map.addLayer(c);\n        }\n      });\n    });\n    Object.values(layers).forEach(function (lg) {\n      var v = lg.visibility;\n      lg.config.forEach(function (c) {\n        if (utils.generic.isFunction(map.setLayoutProperty)) {\n          map.setLayoutProperty(c.id, 'visibility', v);\n        }\n      });\n    });\n    return map;\n  },\n  addDefaultSources: function addDefaultSources(map) {\n    if (!map) return map;\n    if (!map.getSource('mapbox-streets')) map.addSource('mapbox-streets', config.mapbox.sources.streets);\n    if (!map.getSource('mapbox-terrain')) map.addSource('mapbox-terrain', config.mapbox.sources.terrain);\n    return map;\n  },\n  getLevelByZoom: function getLevelByZoom(levels, zoom) {\n    if (!utils.generic.isValidArray(levels, true)) return;\n    var level;\n    levels.forEach(function (lvl) {\n      var _lvl = _slicedToArray(lvl, 3),\n          operator = _lvl[0],\n          levelZoom = _lvl[1],\n          levelType = _lvl[2];\n\n      if (utils.generic.getWithDynamicOperator(zoom, operator, levelZoom)) {\n        level = levelType;\n      }\n    });\n    return level;\n  },\n  getZoomOptions: function getZoomOptions(levels) {\n    if (!utils.generic.isValidArray(levels)) return [];\n    var uniqueLevels = {};\n    levels.forEach(function (level) {\n      if (uniqueLevels[level[2]]) return;\n      uniqueLevels[level[2]] = {\n        id: level[2],\n        zoom: level[1],\n        label: utils.string.t(\"map.levels.\".concat(level[2]))\n      };\n    });\n    return Object.values(uniqueLevels);\n  },\n  getLevelOption: function getLevelOption(levelOptions, level) {\n    if (!utils.generic.isValidArray(levelOptions, true) || !level) return;\n    return levelOptions.find(function (option) {\n      return option.id === level;\n    });\n  }\n};\nexport default utilsMap;","map":{"version":3,"sources":["E:/MPHASIS/claims-page/Mphasis-Edge/src/utils/map/map.js"],"names":["mapboxgl","isEqual","get","utils","config","utilsMap","visibility","visible","none","setMarkers","mapInstance","locations","markers","generic","isValidArray","markersArray","parseLocations","forEach","location","bespokeColor","color","mapbox","marker","active","Marker","setLngLat","lng","lat","markerExists","find","m","getLngLat","addTo","push","filter","locationsFound","sort","a","b","addDefaultLayers","map","layers","Object","values","lg","c","isFunction","addLayer","getLayer","id","v","setLayoutProperty","addDefaultSources","getSource","addSource","sources","streets","terrain","getLevelByZoom","levels","zoom","level","lvl","operator","levelZoom","levelType","getWithDynamicOperator","getZoomOptions","uniqueLevels","label","string","t","getLevelOption","levelOptions","option"],"mappings":"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","sourcesContent":["import mapboxgl from 'mapbox-gl';\r\nimport isEqual from 'lodash/isEqual';\r\nimport get from 'lodash/get';\r\n\r\n// app\r\nimport * as utils from 'utils';\r\nimport config from 'config';\r\n\r\nconst utilsMap = {\r\n  visibility: {\r\n    visible: 'visible',\r\n    none: 'none',\r\n  },\r\n\r\n  setMarkers: (mapInstance, locations, markers = []) => {\r\n    if (!mapInstance || !locations || !utils.generic.isValidArray(markers)) return;\r\n\r\n    const markersArray = [];\r\n\r\n    utilsMap.parseLocations(locations).forEach((location) => {\r\n      const bespokeColor = get(location, 'properties.backgroundColor[0]');\r\n      const color = bespokeColor || config.mapbox.marker.color[location.active ? 'active' : 'default'];\r\n      const marker = new mapboxgl.Marker({ color }).setLngLat([location.lng, location.lat]);\r\n      const markerExists = markers.find((m) => isEqual(m.getLngLat(), marker.getLngLat()));\r\n\r\n      if (markerExists) return;\r\n\r\n      // adding original location object (id, lat, lng, etc...) to the marker\r\n      marker.location = location;\r\n\r\n      try {\r\n        marker.addTo(mapInstance);\r\n      } catch {}\r\n\r\n      markersArray.push(marker);\r\n    });\r\n\r\n    return markersArray;\r\n  },\r\n\r\n  parseLocations: (locations) => {\r\n    if (!utils.generic.isValidArray(locations, true)) return [];\r\n\r\n    return locations\r\n      .filter((location) => {\r\n        return location && location.locationsFound > 0;\r\n      })\r\n      .sort((a, b) => {\r\n        if (!a || !b) return false;\r\n        if ((!a.lat && a.lat !== 0) || (!b.lat && b.lat !== 0)) return false;\r\n        return b.lat - a.lat;\r\n      });\r\n  },\r\n\r\n  addDefaultLayers: (map, layers) => {\r\n    if (!map || !layers || typeof layers !== 'object') return map;\r\n\r\n    Object.values(layers).forEach((lg) => {\r\n      lg.config.forEach((c) => {\r\n        if (utils.generic.isFunction(map.addLayer) && !map.getLayer(c.id)) {\r\n          map.addLayer(c);\r\n        }\r\n      });\r\n    });\r\n\r\n    Object.values(layers).forEach((lg) => {\r\n      let v = lg.visibility;\r\n\r\n      lg.config.forEach((c) => {\r\n        if (utils.generic.isFunction(map.setLayoutProperty)) {\r\n          map.setLayoutProperty(c.id, 'visibility', v);\r\n        }\r\n      });\r\n    });\r\n\r\n    return map;\r\n  },\r\n\r\n  addDefaultSources: (map) => {\r\n    if (!map) return map;\r\n\r\n    if (!map.getSource('mapbox-streets')) map.addSource('mapbox-streets', config.mapbox.sources.streets);\r\n    if (!map.getSource('mapbox-terrain')) map.addSource('mapbox-terrain', config.mapbox.sources.terrain);\r\n\r\n    return map;\r\n  },\r\n\r\n  getLevelByZoom: (levels, zoom) => {\r\n    if (!utils.generic.isValidArray(levels, true)) return;\r\n    let level;\r\n    levels.forEach((lvl) => {\r\n      const [operator, levelZoom, levelType] = lvl;\r\n      if (utils.generic.getWithDynamicOperator(zoom, operator, levelZoom)) {\r\n        level = levelType;\r\n      }\r\n    });\r\n    return level;\r\n  },\r\n\r\n  getZoomOptions: (levels) => {\r\n    if (!utils.generic.isValidArray(levels)) return [];\r\n    const uniqueLevels = {};\r\n    levels.forEach((level) => {\r\n      if (uniqueLevels[level[2]]) return;\r\n      uniqueLevels[level[2]] = {\r\n        id: level[2],\r\n        zoom: level[1],\r\n        label: utils.string.t(`map.levels.${level[2]}`),\r\n      };\r\n    });\r\n    return Object.values(uniqueLevels);\r\n  },\r\n\r\n  getLevelOption: (levelOptions, level) => {\r\n    if (!utils.generic.isValidArray(levelOptions, true) || !level) return;\r\n    return levelOptions.find((option) => option.id === level);\r\n  },\r\n};\r\n\r\nexport default utilsMap;\r\n"]},"metadata":{},"sourceType":"module"}