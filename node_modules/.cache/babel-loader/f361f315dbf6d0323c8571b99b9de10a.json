{"ast":null,"code":"import \"core-js/modules/es.array.filter\";\nimport { firstBy } from 'thenby';\nimport toNumber from 'lodash/toNumber';\nimport round from 'lodash/round';\nimport uniq from 'lodash/uniq';\nimport get from 'lodash/get'; // app\n\nimport * as utils from 'utils';\nimport config from 'config';\nimport { MARKETS_STATUS_ID_ORDER } from 'consts';\n\nvar valid = function valid() {\n  var markets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return utils.generic.isValidArray(markets, true);\n};\n\nvar utilsMarkets = {\n  getByStatusIds: function getByStatusIds() {\n    var markets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var statusIdsArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    if (!valid(markets) || !utils.generic.isValidArray(statusIdsArray, true)) return [];\n    return markets.filter(function (market) {\n      return statusIdsArray.includes(get(market, 'statusId'));\n    });\n  },\n  filterByLineToStand: function filterByLineToStand() {\n    var markets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    if (!valid(markets)) return [];\n    return markets.filter(function (market) {\n      return utils.market.isLineToStand(market);\n    });\n  },\n  getCurrency: function getCurrency(markets) {\n    if (!valid(markets)) return;\n    var currencies = markets.filter(function (market) {\n      return utils.market.getCurrency(market);\n    }).map(function (market) {\n      return utils.market.getCurrency(market);\n    });\n    return uniq(currencies).length === 1 ? uniq(currencies)[0] : false;\n  },\n  // layer OMS\n  // false/false means we want the total gross premium amount\n  // it is assumed that ALL markets within a policy have the same currency\n  // as per Alex, the B/E will also follow that assumption\n  // this will always return an object with a single currency, eg. { \"USD\": 1000 }\n  getPremiumByCurrency: function getPremiumByCurrency() {\n    var markets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var currency = arguments.length > 1 ? arguments[1] : undefined;\n    var isSigned = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var toOrder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    if (!valid(markets) || !currency) return {};\n    return markets.reduce(function (acc, market) {\n      var lineSize = toOrder ? utils.market.getLineSize(market, isSigned) / 100 : 1 / markets.length;\n      var premium = utils.market.getPremium(market);\n      if (!acc[currency]) acc[currency] = 0;\n      acc[currency] = acc[currency] + lineSize * premium;\n      return acc;\n    }, {});\n  },\n  // policy GXB\n  // true/true means we want the premium value signed and ordered (based on markets %)\n  getPremiumBySettlementCurrency: function getPremiumBySettlementCurrency() {\n    var markets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var isSigned = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var toOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!valid(markets)) return {};\n    return markets.reduce(function (acc, market) {\n      var lineSize = toOrder ? utils.market.getLineSize(market, isSigned) / 100 : 1 / markets.length;\n      var premium = utils.market.getPremium(market);\n      var currencyCode = utils.market.getSettlementIsoCode(market);\n      if (!acc[currencyCode]) acc[currencyCode] = 0;\n      acc[currencyCode] = acc[currencyCode] + lineSize * premium;\n      return acc;\n    }, {});\n  },\n  // TODO added on 17/11/2020: this should be removed if market(s) have support for \"getLineSizeByCurrency\"\n  getLineSize: function getLineSize() {\n    var markets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var isSigned = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!valid(markets)) return 0;\n    return markets.reduce(function (acc, market) {\n      var lineSize = utils.market.getLineSize(market, isSigned);\n      return acc + lineSize;\n    }, 0);\n  },\n  // TODO added on 17/11/2020: until markets have currency code, this method is useless\n  // getLineSizeByCurrency: (markets = [], currency, isSigned = false) => {\n  //   if (!valid(markets) || !currency) return 0;\n  //\n  //   return markets.reduce((acc, market) => {\n  //     let lineSize = utils.market.getLineSizeByCurrency(market, currency, isSigned);\n  //     return acc + lineSize;\n  //   }, 0);\n  // },\n  hasMultiplePremiums: function hasMultiplePremiums() {\n    var markets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    if (!valid(markets)) return;\n    var premiums = markets.map(function (market) {\n      return utils.market.getPremium(market);\n    });\n    return uniq(premiums).length > 1;\n  },\n  order: function order() {\n    var markets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var byUnderwriterGroup = arguments.length > 1 ? arguments[1] : undefined;\n    if (!valid(markets)) return [];\n\n    if (byUnderwriterGroup) {\n      return markets.sort(firstBy(utils.sort.array('lexical', 'underwriterGroup', 'asc', true)).thenBy(utils.sort.array('lexical', 'uniqueMarketReference', 'asc', true)).thenBy(utils.sort.array('customSort', 'statusId', '', true, MARKETS_STATUS_ID_ORDER)).thenBy(utils.sort.array('boolean', 'isLeader')).thenBy(utils.sort.array('numeric', 'premium', 'asc', true)).thenBy(utils.sort.array('numeric', 'writtenLinePercentage', 'desc', true)).thenBy(utils.sort.array('lexical', 'section', 'ASC', true)));\n    }\n\n    return markets.sort(firstBy(utils.sort.array('lexical', 'uniqueMarketReference', 'asc', true)).thenBy(utils.sort.array('customSort', 'statusId', '', true, MARKETS_STATUS_ID_ORDER)).thenBy(utils.sort.array('boolean', 'isLeader')).thenBy(utils.sort.array('numeric', 'premium', 'asc', true)).thenBy(utils.sort.array('numeric', 'writtenLinePercentage', 'desc', true)).thenBy(utils.sort.array('lexical', 'section', 'ASC', true)));\n  },\n  signDown: function signDown() {\n    var markets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var percentage = arguments.length > 1 ? arguments[1] : undefined;\n    var isZero = percentage === 0 || percentage === '0';\n    var isPercentage = isZero || toNumber(percentage) > 0;\n    if (markets.length <= 0 || !isPercentage) return markets;\n    var toStand = markets.reduce(function (acc, market) {\n      return acc + (utils.market.isLineToStand(market) ? utils.market.getLineSize(market) : 0);\n    }, 0);\n    var toSignDown = markets.reduce(function (acc, market) {\n      return acc + (utils.market.isLineToStand(market) ? 0 : utils.market.getLineSize(market));\n    }, 0);\n    var available = Math.max(0, percentage - toStand);\n    return markets.map(function (market) {\n      var writtenLinePercentage = utils.market.getLineSize(market);\n\n      if (utils.market.isLineToStand(market)) {\n        return utils.market.setSigned(market, writtenLinePercentage);\n      } else {\n        var signed = round(writtenLinePercentage / toSignDown * available, config.ui.format.percent.decimal);\n        return utils.market.setSigned(market, signed);\n      }\n    });\n  }\n};\nexport default utilsMarkets;","map":{"version":3,"sources":["E:/MPHASIS/claims-page/Mphasis-Edge/src/utils/markets/markets.js"],"names":["firstBy","toNumber","round","uniq","get","utils","config","MARKETS_STATUS_ID_ORDER","valid","markets","generic","isValidArray","utilsMarkets","getByStatusIds","statusIdsArray","filter","market","includes","filterByLineToStand","isLineToStand","getCurrency","currencies","map","length","getPremiumByCurrency","currency","isSigned","toOrder","reduce","acc","lineSize","getLineSize","premium","getPremium","getPremiumBySettlementCurrency","currencyCode","getSettlementIsoCode","hasMultiplePremiums","premiums","order","byUnderwriterGroup","sort","array","thenBy","signDown","percentage","isZero","isPercentage","toStand","toSignDown","available","Math","max","writtenLinePercentage","setSigned","signed","ui","format","percent","decimal"],"mappings":"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","sourcesContent":["import { firstBy } from 'thenby';\r\nimport toNumber from 'lodash/toNumber';\r\nimport round from 'lodash/round';\r\nimport uniq from 'lodash/uniq';\r\nimport get from 'lodash/get';\r\n\r\n// app\r\nimport * as utils from 'utils';\r\nimport config from 'config';\r\nimport { MARKETS_STATUS_ID_ORDER } from 'consts';\r\n\r\nconst valid = (markets = []) => {\r\n  return utils.generic.isValidArray(markets, true);\r\n};\r\n\r\nconst utilsMarkets = {\r\n  getByStatusIds: (markets = [], statusIdsArray = []) => {\r\n    if (!valid(markets) || !utils.generic.isValidArray(statusIdsArray, true)) return [];\r\n\r\n    return markets.filter((market) => {\r\n      return statusIdsArray.includes(get(market, 'statusId'));\r\n    });\r\n  },\r\n\r\n  filterByLineToStand: (markets = []) => {\r\n    if (!valid(markets)) return [];\r\n\r\n    return markets.filter((market) => {\r\n      return utils.market.isLineToStand(market);\r\n    });\r\n  },\r\n\r\n  getCurrency: (markets) => {\r\n    if (!valid(markets)) return;\r\n\r\n    const currencies = markets.filter((market) => utils.market.getCurrency(market)).map((market) => utils.market.getCurrency(market));\r\n\r\n    return uniq(currencies).length === 1 ? uniq(currencies)[0] : false;\r\n  },\r\n\r\n  // layer OMS\r\n  // false/false means we want the total gross premium amount\r\n  // it is assumed that ALL markets within a policy have the same currency\r\n  // as per Alex, the B/E will also follow that assumption\r\n  // this will always return an object with a single currency, eg. { \"USD\": 1000 }\r\n  getPremiumByCurrency: (markets = [], currency, isSigned = false, toOrder = false) => {\r\n    if (!valid(markets) || !currency) return {};\r\n\r\n    return markets.reduce((acc, market) => {\r\n      let lineSize = toOrder ? utils.market.getLineSize(market, isSigned) / 100 : 1 / markets.length;\r\n      let premium = utils.market.getPremium(market);\r\n\r\n      if (!acc[currency]) acc[currency] = 0;\r\n      acc[currency] = acc[currency] + lineSize * premium;\r\n\r\n      return acc;\r\n    }, {});\r\n  },\r\n\r\n  // policy GXB\r\n  // true/true means we want the premium value signed and ordered (based on markets %)\r\n  getPremiumBySettlementCurrency: (markets = [], isSigned = false, toOrder = false) => {\r\n    if (!valid(markets)) return {};\r\n    return markets.reduce((acc, market) => {\r\n      let lineSize = toOrder ? utils.market.getLineSize(market, isSigned) / 100 : 1 / markets.length;\r\n      let premium = utils.market.getPremium(market);\r\n      let currencyCode = utils.market.getSettlementIsoCode(market);\r\n\r\n      if (!acc[currencyCode]) acc[currencyCode] = 0;\r\n      acc[currencyCode] = acc[currencyCode] + lineSize * premium;\r\n\r\n      return acc;\r\n    }, {});\r\n  },\r\n\r\n  // TODO added on 17/11/2020: this should be removed if market(s) have support for \"getLineSizeByCurrency\"\r\n  getLineSize: (markets = [], isSigned = false) => {\r\n    if (!valid(markets)) return 0;\r\n\r\n    return markets.reduce((acc, market) => {\r\n      let lineSize = utils.market.getLineSize(market, isSigned);\r\n      return acc + lineSize;\r\n    }, 0);\r\n  },\r\n\r\n  // TODO added on 17/11/2020: until markets have currency code, this method is useless\r\n  // getLineSizeByCurrency: (markets = [], currency, isSigned = false) => {\r\n  //   if (!valid(markets) || !currency) return 0;\r\n  //\r\n  //   return markets.reduce((acc, market) => {\r\n  //     let lineSize = utils.market.getLineSizeByCurrency(market, currency, isSigned);\r\n  //     return acc + lineSize;\r\n  //   }, 0);\r\n  // },\r\n\r\n  hasMultiplePremiums: (markets = []) => {\r\n    if (!valid(markets)) return;\r\n\r\n    const premiums = markets.map((market) => utils.market.getPremium(market));\r\n    return uniq(premiums).length > 1;\r\n  },\r\n\r\n  order: (markets = [], byUnderwriterGroup) => {\r\n    if (!valid(markets)) return [];\r\n\r\n    if (byUnderwriterGroup) {\r\n      return markets.sort(\r\n        firstBy(utils.sort.array('lexical', 'underwriterGroup', 'asc', true))\r\n          .thenBy(utils.sort.array('lexical', 'uniqueMarketReference', 'asc', true))\r\n          .thenBy(utils.sort.array('customSort', 'statusId', '', true, MARKETS_STATUS_ID_ORDER))\r\n          .thenBy(utils.sort.array('boolean', 'isLeader'))\r\n          .thenBy(utils.sort.array('numeric', 'premium', 'asc', true))\r\n          .thenBy(utils.sort.array('numeric', 'writtenLinePercentage', 'desc', true))\r\n          .thenBy(utils.sort.array('lexical', 'section', 'ASC', true))\r\n      );\r\n    }\r\n\r\n    return markets.sort(\r\n      firstBy(utils.sort.array('lexical', 'uniqueMarketReference', 'asc', true))\r\n        .thenBy(utils.sort.array('customSort', 'statusId', '', true, MARKETS_STATUS_ID_ORDER))\r\n        .thenBy(utils.sort.array('boolean', 'isLeader'))\r\n        .thenBy(utils.sort.array('numeric', 'premium', 'asc', true))\r\n        .thenBy(utils.sort.array('numeric', 'writtenLinePercentage', 'desc', true))\r\n        .thenBy(utils.sort.array('lexical', 'section', 'ASC', true))\r\n    );\r\n  },\r\n\r\n  signDown: (markets = [], percentage) => {\r\n    const isZero = percentage === 0 || percentage === '0';\r\n    const isPercentage = isZero || toNumber(percentage) > 0;\r\n\r\n    if (markets.length <= 0 || !isPercentage) return markets;\r\n\r\n    const toStand = markets.reduce((acc, market) => {\r\n      return acc + (utils.market.isLineToStand(market) ? utils.market.getLineSize(market) : 0);\r\n    }, 0);\r\n\r\n    const toSignDown = markets.reduce((acc, market) => {\r\n      return acc + (utils.market.isLineToStand(market) ? 0 : utils.market.getLineSize(market));\r\n    }, 0);\r\n\r\n    const available = Math.max(0, percentage - toStand);\r\n\r\n    return markets.map((market) => {\r\n      const writtenLinePercentage = utils.market.getLineSize(market);\r\n\r\n      if (utils.market.isLineToStand(market)) {\r\n        return utils.market.setSigned(market, writtenLinePercentage);\r\n      } else {\r\n        const signed = round((writtenLinePercentage / toSignDown) * available, config.ui.format.percent.decimal);\r\n        return utils.market.setSigned(market, signed);\r\n      }\r\n    });\r\n  },\r\n};\r\n\r\nexport default utilsMarkets;\r\n"]},"metadata":{},"sourceType":"module"}