{"ast":null,"code":"import _objectSpread from \"E:/MPHASIS/claims-page/Mphasis-Edge/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _toConsumableArray from \"E:/MPHASIS/claims-page/Mphasis-Edge/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport drop from 'lodash/drop';\nimport orderBy from 'lodash/orderBy';\nimport isNumber from 'lodash/isNumber';\nimport flatten from 'lodash/flatten'; // app\n\nimport * as utils from 'utils';\n\nvar getSeeNoteMessage = function getSeeNoteMessage(comments, placementId, market, lIndex, pIndex, mIndex) {\n  var hasNotes = !!comments[\"placement/\".concat(placementId, \"/policyMarket/\").concat(market.id)] || market.subjectivities;\n  if (!hasNotes) return;\n  return \"\".concat(lIndex + 1, \".\").concat(pIndex + 1, \".\").concat(mIndex + 1);\n};\n\nvar getMarketsOrdered = function getMarketsOrdered(markets) {\n  return utils.markets.order(markets);\n};\n\nexport var getNoteCount = function getNoteCount(page) {\n  if (!utils.generic.isValidArray(page)) return 0;\n  return page.reduce(function (pageAcc, pageSection) {\n    var charLimit = 120;\n    var subjectivitiesChars = pageSection.subjectivities ? 2 : 0;\n    var messageChars = pageSection.comments ? pageSection.comments.reduce(function (noteAcc, comment) {\n      return noteAcc + comment.message.length;\n    }, 0) / charLimit : 0;\n    return Math.ceil(subjectivitiesChars + messageChars + pageAcc);\n  }, 0);\n};\nexport var getMarketRowCount = function getMarketRowCount(markets) {\n  if (!utils.generic.isValidArray(markets)) return 0;\n  return markets.length + markets.map(function (market) {\n    return market.seeNoteMessage ? 2 : 0;\n  }).reduce(function (a, c) {\n    return a + c;\n  }, 0);\n}; // return grouped arrays of no more than the row limit (taking into account the seeNoteMessage row)\n\nexport var marketChunk = function marketChunk(markets, rowLimit) {\n  if (!utils.generic.isValidArray(markets) || !isNumber(rowLimit)) return [];\n  return markets.reduce(function (marketChunks, market) {\n    var count = marketChunks[marketChunks.length - 1] ? getMarketRowCount(marketChunks[marketChunks.length - 1]) : 0;\n    var current = getMarketRowCount([market]);\n\n    if (count + current <= rowLimit) {\n      if (!marketChunks.length) marketChunks.push([]);\n      marketChunks[marketChunks.length - 1] = [].concat(_toConsumableArray(marketChunks[marketChunks.length - 1]), [market]);\n    } else {\n      marketChunks.push([market]);\n    }\n\n    return marketChunks;\n  }, []);\n};\nexport var getRowCount = function getRowCount(policies) {\n  if (!utils.generic.isValidArray(policies, true)) return 0;\n  var noteCount = policies.map(function (policy) {\n    return getMarketRowCount(policy.markets);\n  }).reduce(function (a, c) {\n    return a + c;\n  }, 0);\n  return policies.length + noteCount;\n};\n\nvar addPolicyPages = function addPolicyPages(marketSegments, isFirstPolicy, showMudmap, businessType, policy, pdfPages) {\n  marketSegments.forEach(function (marketSegment, index) {\n    var page = {}; // Add first market segment to a page\n\n    if (index === 0) {\n      page.title = isFirstPolicy && !showMudmap ? businessType.businessTypeName : \"\".concat(businessType.businessTypeName, \" (continued)\");\n      page.policies = [policy];\n    } // Add remaining markets of a policy to a new page\n\n\n    if (index > 0) {\n      page.title = \"\".concat(businessType.businessTypeName, \" (continued)\");\n      page.policies = [_objectSpread(_objectSpread({}, policy), {}, {\n        markets: marketSegment,\n        showHeaderRow: false\n      })];\n    }\n\n    pdfPages.push(page);\n  });\n};\n\nexport var addCommentPages = function addCommentPages(businessType, comments, pdfPages, placementId, rowLimit) {\n  var notes = businessType.policies.map(function (policy) {\n    return policy.markets.map(function (market) {\n      return {\n        title: market.seeNoteMessage,\n        subjectivities: market.subjectivities,\n        comments: comments[\"placement/\".concat(placementId, \"/policyMarket/\").concat(market.id)]\n      };\n    }).filter(function (_ref) {\n      var comments = _ref.comments,\n          subjectivities = _ref.subjectivities;\n      return comments || subjectivities;\n    });\n  }).filter(function (notes) {\n    return notes.length;\n  });\n  var notePages = flatten(notes).reduce(function (acc, note) {\n    var previousPage = acc[acc.length - 1];\n    var previousPageCount = previousPage ? getNoteCount(acc[acc.length - 1]) : 0;\n    var currentPageCount = getNoteCount([note]);\n    var totalCount = previousPageCount + currentPageCount;\n\n    if (totalCount < rowLimit) {\n      if (!acc.length) acc.push([]);\n      acc[acc.length - 1] = [].concat(_toConsumableArray(acc[acc.length - 1]), [note]);\n    } else {\n      acc.push([note]);\n    }\n\n    return acc;\n  }, []);\n  notePages.forEach(function (page) {\n    pdfPages.push({\n      title: \"\".concat(businessType.businessTypeName, \" (continued)\"),\n      notes: page\n    });\n  });\n};\nvar utilsPlacementPDF = {\n  getAccumulatedRowCount: function getAccumulatedRowCount(markets, rowLimit) {\n    if (!utils.generic.isValidArray(markets) || !isNumber(rowLimit)) return [];\n    return markets.reduce(function (acc, market) {\n      var count = getMarketRowCount(acc);\n      var current = getMarketRowCount([market]);\n\n      if (count + current <= rowLimit) {\n        acc.push(market);\n      }\n\n      return acc;\n    }, []);\n  },\n  getPages: function getPages(businessTypes, userSelectedConfig, comments, placementId) {\n    var pages = [];\n    businessTypes.forEach(function (businessType) {\n      var policyCount = businessType.policies.length;\n\n      var reducer = function reducer(pdfPages, policy, index) {\n        var rowLimit = 20;\n        var isFirstPolicy = index === 0;\n        var isLastPolicy = policyCount === index + 1;\n        var previousPage = pdfPages[pdfPages.length - 1];\n        var showMudmap = isFirstPolicy && userSelectedConfig.showMudmap && businessType.mudmap && businessType.mudmap.length > 0;\n        var remainingSpace = rowLimit - (previousPage ? getRowCount(previousPage.policies) : 0); // Add mudmap before first policy only\n\n        if (isFirstPolicy && showMudmap) {\n          pdfPages.push({\n            title: businessType.businessTypeName,\n            mudmap: businessType.mudmap\n          });\n        } // Fill any space on previous page, then populate new pages\n\n\n        if (!isFirstPolicy && remainingSpace > getRowCount([policy])) {\n          var remainingMarkets = drop(policy.markets, utilsPlacementPDF.getAccumulatedRowCount(policy.markets, remainingSpace).length);\n\n          var _previousPage = pdfPages.length - 1;\n\n          pdfPages.splice(_previousPage, 1, _objectSpread(_objectSpread({}, pdfPages[_previousPage]), {}, {\n            policies: [_objectSpread(_objectSpread({}, policy || {}), {}, {\n              markets: policy.markets\n            })].concat(_toConsumableArray(pdfPages[_previousPage].policies || []))\n          }));\n          addPolicyPages(marketChunk(remainingMarkets, 20), isFirstPolicy, showMudmap, businessType, policy, pdfPages);\n        } else {\n          // Populate new pages\n          addPolicyPages(marketChunk(policy.markets, 20), isFirstPolicy, showMudmap, businessType, policy, pdfPages);\n        } // Add notes after the last policy\n\n\n        if (isLastPolicy) {\n          addCommentPages(businessType, comments, pdfPages, placementId, rowLimit);\n        }\n\n        return pdfPages;\n      };\n\n      var splitPolicies = orderBy(businessType.policies, ['excess', 'amount'], ['asc', 'asc']).reduce(reducer, []);\n      pages = [].concat(_toConsumableArray(pages), _toConsumableArray(splitPolicies));\n    });\n    return pages;\n  },\n  getPDFMarkets: function getPDFMarkets(markets, comments, placementId, lIndex, pIndex) {\n    if (!utils.generic.isValidArray(markets) || !utils.generic.isValidObject(comments) || !placementId) return [];\n    return getMarketsOrdered(markets).map(function (market, mIndex) {\n      return _objectSpread(_objectSpread({}, market), {}, {\n        seeNoteMessage: getSeeNoteMessage(comments, placementId, market, lIndex, pIndex, mIndex)\n      });\n    });\n  }\n};\nexport default utilsPlacementPDF;","map":{"version":3,"sources":["E:/MPHASIS/claims-page/Mphasis-Edge/src/utils/placementPDF/placementPDF.js"],"names":["drop","orderBy","isNumber","flatten","utils","getSeeNoteMessage","comments","placementId","market","lIndex","pIndex","mIndex","hasNotes","id","subjectivities","getMarketsOrdered","markets","order","getNoteCount","page","generic","isValidArray","reduce","pageAcc","pageSection","charLimit","subjectivitiesChars","messageChars","noteAcc","comment","message","length","Math","ceil","getMarketRowCount","map","seeNoteMessage","a","c","marketChunk","rowLimit","marketChunks","count","current","push","getRowCount","policies","noteCount","policy","addPolicyPages","marketSegments","isFirstPolicy","showMudmap","businessType","pdfPages","forEach","marketSegment","index","title","businessTypeName","showHeaderRow","addCommentPages","notes","filter","notePages","acc","note","previousPage","previousPageCount","currentPageCount","totalCount","utilsPlacementPDF","getAccumulatedRowCount","getPages","businessTypes","userSelectedConfig","pages","policyCount","reducer","isLastPolicy","mudmap","remainingSpace","remainingMarkets","splice","splitPolicies","getPDFMarkets","isValidObject"],"mappings":"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","sourcesContent":["import drop from 'lodash/drop';\r\nimport orderBy from 'lodash/orderBy';\r\nimport isNumber from 'lodash/isNumber';\r\nimport flatten from 'lodash/flatten';\r\n\r\n// app\r\nimport * as utils from 'utils';\r\n\r\nconst getSeeNoteMessage = (comments, placementId, market, lIndex, pIndex, mIndex) => {\r\n  const hasNotes = !!comments[`placement/${placementId}/policyMarket/${market.id}`] || market.subjectivities;\r\n  if (!hasNotes) return;\r\n  return `${lIndex + 1}.${pIndex + 1}.${mIndex + 1}`;\r\n};\r\n\r\nconst getMarketsOrdered = (markets) => utils.markets.order(markets);\r\n\r\nexport const getNoteCount = (page) => {\r\n  if (!utils.generic.isValidArray(page)) return 0;\r\n  return page.reduce((pageAcc, pageSection) => {\r\n    const charLimit = 120;\r\n    const subjectivitiesChars = pageSection.subjectivities ? 2 : 0;\r\n    const messageChars = pageSection.comments\r\n      ? pageSection.comments.reduce((noteAcc, comment) => noteAcc + comment.message.length, 0) / charLimit\r\n      : 0;\r\n    return Math.ceil(subjectivitiesChars + messageChars + pageAcc);\r\n  }, 0);\r\n};\r\n\r\nexport const getMarketRowCount = (markets) => {\r\n  if (!utils.generic.isValidArray(markets)) return 0;\r\n  return markets.length + markets.map((market) => (market.seeNoteMessage ? 2 : 0)).reduce((a, c) => a + c, 0);\r\n};\r\n\r\n// return grouped arrays of no more than the row limit (taking into account the seeNoteMessage row)\r\nexport const marketChunk = (markets, rowLimit) => {\r\n  if (!utils.generic.isValidArray(markets) || !isNumber(rowLimit)) return [];\r\n  return markets.reduce((marketChunks, market) => {\r\n    const count = marketChunks[marketChunks.length - 1] ? getMarketRowCount(marketChunks[marketChunks.length - 1]) : 0;\r\n    const current = getMarketRowCount([market]);\r\n    if (count + current <= rowLimit) {\r\n      if (!marketChunks.length) marketChunks.push([]);\r\n      marketChunks[marketChunks.length - 1] = [...marketChunks[marketChunks.length - 1], market];\r\n    } else {\r\n      marketChunks.push([market]);\r\n    }\r\n    return marketChunks;\r\n  }, []);\r\n};\r\n\r\nexport const getRowCount = (policies) => {\r\n  if (!utils.generic.isValidArray(policies, true)) return 0;\r\n\r\n  const noteCount = policies.map((policy) => getMarketRowCount(policy.markets)).reduce((a, c) => a + c, 0);\r\n\r\n  return policies.length + noteCount;\r\n};\r\n\r\nconst addPolicyPages = (marketSegments, isFirstPolicy, showMudmap, businessType, policy, pdfPages) => {\r\n  marketSegments.forEach((marketSegment, index) => {\r\n    const page = {};\r\n\r\n    // Add first market segment to a page\r\n    if (index === 0) {\r\n      page.title = isFirstPolicy && !showMudmap ? businessType.businessTypeName : `${businessType.businessTypeName} (continued)`;\r\n      page.policies = [policy];\r\n    }\r\n\r\n    // Add remaining markets of a policy to a new page\r\n    if (index > 0) {\r\n      page.title = `${businessType.businessTypeName} (continued)`;\r\n      page.policies = [{ ...policy, markets: marketSegment, showHeaderRow: false }];\r\n    }\r\n\r\n    pdfPages.push(page);\r\n  });\r\n};\r\n\r\nexport const addCommentPages = (businessType, comments, pdfPages, placementId, rowLimit) => {\r\n  const notes = businessType.policies\r\n    .map((policy) =>\r\n      policy.markets\r\n        .map((market) => ({\r\n          title: market.seeNoteMessage,\r\n          subjectivities: market.subjectivities,\r\n          comments: comments[`placement/${placementId}/policyMarket/${market.id}`],\r\n        }))\r\n        .filter(({ comments, subjectivities }) => comments || subjectivities)\r\n    )\r\n    .filter((notes) => notes.length);\r\n\r\n  const notePages = flatten(notes).reduce((acc, note) => {\r\n    const previousPage = acc[acc.length - 1];\r\n    const previousPageCount = previousPage ? getNoteCount(acc[acc.length - 1]) : 0;\r\n    const currentPageCount = getNoteCount([note]);\r\n    const totalCount = previousPageCount + currentPageCount;\r\n\r\n    if (totalCount < rowLimit) {\r\n      if (!acc.length) acc.push([]);\r\n      acc[acc.length - 1] = [...acc[acc.length - 1], note];\r\n    } else {\r\n      acc.push([note]);\r\n    }\r\n\r\n    return acc;\r\n  }, []);\r\n\r\n  notePages.forEach((page) => {\r\n    pdfPages.push({ title: `${businessType.businessTypeName} (continued)`, notes: page });\r\n  });\r\n};\r\n\r\nconst utilsPlacementPDF = {\r\n  getAccumulatedRowCount: (markets, rowLimit) => {\r\n    if (!utils.generic.isValidArray(markets) || !isNumber(rowLimit)) return [];\r\n    return markets.reduce((acc, market) => {\r\n      const count = getMarketRowCount(acc);\r\n      const current = getMarketRowCount([market]);\r\n      if (count + current <= rowLimit) {\r\n        acc.push(market);\r\n      }\r\n      return acc;\r\n    }, []);\r\n  },\r\n  getPages: (businessTypes, userSelectedConfig, comments, placementId) => {\r\n    let pages = [];\r\n    businessTypes.forEach((businessType) => {\r\n      const policyCount = businessType.policies.length;\r\n      const reducer = (pdfPages, policy, index) => {\r\n        const rowLimit = 20;\r\n        const isFirstPolicy = index === 0;\r\n        const isLastPolicy = policyCount === index + 1;\r\n        const previousPage = pdfPages[pdfPages.length - 1];\r\n\r\n        const showMudmap = isFirstPolicy && userSelectedConfig.showMudmap && businessType.mudmap && businessType.mudmap.length > 0;\r\n\r\n        const remainingSpace = rowLimit - (previousPage ? getRowCount(previousPage.policies) : 0);\r\n\r\n        // Add mudmap before first policy only\r\n        if (isFirstPolicy && showMudmap) {\r\n          pdfPages.push({\r\n            title: businessType.businessTypeName,\r\n            mudmap: businessType.mudmap,\r\n          });\r\n        }\r\n\r\n        // Fill any space on previous page, then populate new pages\r\n        if (!isFirstPolicy && remainingSpace > getRowCount([policy])) {\r\n          const remainingMarkets = drop(policy.markets, utilsPlacementPDF.getAccumulatedRowCount(policy.markets, remainingSpace).length);\r\n          const previousPage = pdfPages.length - 1;\r\n          pdfPages.splice(previousPage, 1, {\r\n            ...pdfPages[previousPage],\r\n            policies: [{ ...(policy || {}), markets: policy.markets }, ...(pdfPages[previousPage].policies || [])],\r\n          });\r\n          addPolicyPages(marketChunk(remainingMarkets, 20), isFirstPolicy, showMudmap, businessType, policy, pdfPages);\r\n        } else {\r\n          // Populate new pages\r\n          addPolicyPages(marketChunk(policy.markets, 20), isFirstPolicy, showMudmap, businessType, policy, pdfPages);\r\n        }\r\n\r\n        // Add notes after the last policy\r\n        if (isLastPolicy) {\r\n          addCommentPages(businessType, comments, pdfPages, placementId, rowLimit);\r\n        }\r\n\r\n        return pdfPages;\r\n      };\r\n\r\n      const splitPolicies = orderBy(businessType.policies, ['excess', 'amount'], ['asc', 'asc']).reduce(reducer, []);\r\n      pages = [...pages, ...splitPolicies];\r\n    });\r\n    return pages;\r\n  },\r\n  getPDFMarkets: (markets, comments, placementId, lIndex, pIndex) => {\r\n    if (!utils.generic.isValidArray(markets) || !utils.generic.isValidObject(comments) || !placementId) return [];\r\n    return getMarketsOrdered(markets).map((market, mIndex) => ({\r\n      ...market,\r\n      seeNoteMessage: getSeeNoteMessage(comments, placementId, market, lIndex, pIndex, mIndex),\r\n    }));\r\n  },\r\n};\r\n\r\nexport default utilsPlacementPDF;\r\n"]},"metadata":{},"sourceType":"module"}