{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _runes = _interopRequireDefault(require(\"runes\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nvar assertIsValidText = function assertIsValidText(text) {\n  if (typeof text !== 'string') {\n    throw new TypeError('Text should be provided as first argument and be a string.');\n  }\n};\n\nvar assertIsValidChunkSize = function assertIsValidChunkSize(chunkSize) {\n  if (Number.isNaN(chunkSize) || Number.parseInt(chunkSize, 10) <= 0) {\n    throw new TypeError('Size should be provided as 2nd argument and parseInt to a value greater than zero.');\n  }\n};\n\nvar assertIsValidChunkOptions = function assertIsValidChunkOptions(chunkOptions) {\n  if (_typeof(chunkOptions) !== 'object' && typeof chunkOptions !== 'undefined' && chunkOptions !== null && chunkOptions !== '') {\n    throw new TypeError('Options should be provided as 3rd (optional) argument and be an object.\\n' + \"Potential chunkOptions object properties include: ['charLengthMask', 'charLengthType', 'textEncoder']\");\n  }\n};\n\nvar assertIsValidCharLengthMask = function assertIsValidCharLengthMask(charLengthMask, charLengthMaskIntParseIntNaN, charLengthMaskInt) {\n  if (charLengthMaskIntParseIntNaN || charLengthMaskInt < -1) {\n    throw new TypeError('charLengthMask should be provided as a chunkOptions property and parseInt to a value >= -1.');\n  }\n};\n\nvar assertIsValidTextEncoder = function assertIsValidTextEncoder(textEncoder) {\n  if (typeof textEncoder === 'string' || Array.isArray(textEncoder) || typeof textEncoder === 'undefined' || textEncoder === null) {\n    throw new TypeError('textEncoder should be provided as a chunkOptions property and be an object containing the .encode(text).length property.');\n  }\n};\n\nvar assertIsValidCharLengthType = function assertIsValidCharLengthType(charLengthType) {\n  if (typeof charLengthType !== 'string' || !(charLengthType === 'length' || charLengthType === 'TextEncoder')) {\n    throw new TypeError(\"charLengthType should be provided as a chunkOptions property and be a value in ['length', 'TextEncoder']\");\n  }\n};\n\nvar chunkLength = function chunkLength(characters, charLengthMask, charLengthType, textEncoder) {\n  var length;\n\n  if (typeof characters === 'undefined' || characters === null || characters === '') {\n    length = -1;\n  } else {\n    var charactersArray;\n\n    if (typeof characters === 'string') {\n      charactersArray = [characters];\n    } else if (Array.isArray(characters) && characters.length) {\n      charactersArray = characters;\n    }\n\n    if (!Array.isArray(charactersArray) || !charactersArray.length || charactersArray === null) {\n      length = -1;\n    } else if (charLengthMask === 0) {\n      length = charactersArray.map(function (character) {\n        return (charLengthType === 'TextEncoder' ? textEncoder.encode(character) : character).length;\n      }).reduce(function (accumulator, currentValue) {\n        return accumulator + currentValue;\n      });\n    } else if (charLengthMask > 0) {\n      var arrayLength = charactersArray.map(function (character) {\n        return (charLengthType === 'TextEncoder' ? textEncoder.encode(character) : character).length;\n      }).reduce(function (accumulator, currentValue) {\n        return accumulator + (currentValue > charLengthMask ? charLengthMask : currentValue);\n      });\n      var maxLength = charactersArray.length * charLengthMask;\n      length = maxLength > arrayLength ? arrayLength : maxLength;\n    } else {\n      length = charactersArray.length;\n    }\n  }\n\n  return length;\n};\n\nvar lastSpaceOrLength = function lastSpaceOrLength(text, upTo) {\n  var lastIndex = text.lastIndexOf(' ', upTo);\n\n  if (lastIndex === -1) {\n    lastIndex = upTo;\n  }\n\n  if (lastIndex > text.length || upTo >= text.length) {\n    lastIndex = text.length;\n  }\n\n  return lastIndex;\n};\n\nvar chunkIndexOf = function chunkIndexOf(characters, chunkSize, charLengthMask, charLengthType, textEncoder) {\n  var splitAt = lastSpaceOrLength(characters, chunkSize);\n\n  while (splitAt > 0 && chunkSize < chunkLength(characters.slice(0, splitAt), charLengthMask, charLengthType, textEncoder)) {\n    splitAt = splitAt - 1;\n  }\n\n  splitAt = lastSpaceOrLength(characters, splitAt);\n\n  if (splitAt > -2 && splitAt < 1 || characters[splitAt] === ' ') {\n    splitAt = splitAt + 1;\n  }\n\n  if (splitAt > characters.length || splitAt < 0 || splitAt === 0 && characters.length === 1) {\n    splitAt = characters.length;\n  }\n\n  return splitAt;\n};\n\nvar _default = function _default(text, chunkSize, chunkOptions) {\n  assertIsValidText(text);\n  var chunkSizeInt = Number.parseInt(chunkSize, 10);\n  assertIsValidChunkSize(chunkSizeInt);\n  assertIsValidChunkOptions(chunkOptions);\n  var charLengthMaskInt = -1;\n  var charLengthMaskIntParseInt = -1;\n  var charLengthMaskIntParseIntNaN = true;\n  var textEncoderObject;\n\n  if (_typeof(chunkOptions) === 'object') {\n    if (Object.prototype.hasOwnProperty.call(chunkOptions, 'charLengthMask')) {\n      charLengthMaskInt = chunkOptions.charLengthMask;\n      charLengthMaskIntParseInt = Number.parseInt(charLengthMaskInt, 10);\n      charLengthMaskIntParseIntNaN = Number.isNaN(charLengthMaskIntParseInt);\n      assertIsValidCharLengthMask(charLengthMaskInt, charLengthMaskIntParseIntNaN, charLengthMaskIntParseInt);\n    }\n\n    if (Object.prototype.hasOwnProperty.call(chunkOptions, 'charLengthType')) {\n      assertIsValidCharLengthType(chunkOptions.charLengthType);\n\n      if (chunkOptions.charLengthType === 'TextEncoder') {\n        if (Object.prototype.hasOwnProperty.call(chunkOptions, 'textEncoder')) {\n          assertIsValidTextEncoder(chunkOptions.textEncoder);\n          textEncoderObject = chunkOptions.textEncoder;\n        }\n      }\n    }\n  }\n\n  var charLengthMask = charLengthMaskIntParseIntNaN ? -1 : charLengthMaskIntParseInt;\n  var charLengthType = _typeof(chunkOptions) === 'object' && chunkOptions.charLengthType ? chunkOptions.charLengthType : 'length';\n\n  try {\n    if (charLengthType === 'TextEncoder' && (typeof textEncoderObject === 'undefined' || textEncoderObject === null || textEncoderObject === '')) {\n      textEncoderObject = new TextEncoder();\n    }\n  } catch (ex) {\n    throw new ReferenceError(\"TextEncoder is not natively defined, new TextEncoder must be passed in with the 'chunkOptions.textEncoder' property.\");\n  }\n\n  var textEncoder = textEncoderObject;\n  var chunks = [];\n  var characters = (0, _runes[\"default\"])(text);\n\n  while (chunkLength(characters, charLengthMask, charLengthType, textEncoder) > 0) {\n    var splitAt = chunkIndexOf(characters, chunkSizeInt, charLengthMask, charLengthType, textEncoder);\n    var chunk = characters.slice(0, splitAt).join('').trim();\n\n    if (chunk !== '' && chunk !== null) {\n      chunks.push(chunk);\n    }\n\n    characters = characters.slice(splitAt);\n  }\n\n  return chunks;\n};\n\nexports[\"default\"] = _default;\nmodule.exports = exports.default;","map":{"version":3,"sources":["E:/MPHASIS/claims-page/Mphasis-Edge/node_modules/chunk-text/dist/index.js"],"names":["Object","defineProperty","exports","value","_runes","_interopRequireDefault","require","obj","__esModule","_typeof","Symbol","iterator","constructor","prototype","assertIsValidText","text","TypeError","assertIsValidChunkSize","chunkSize","Number","isNaN","parseInt","assertIsValidChunkOptions","chunkOptions","assertIsValidCharLengthMask","charLengthMask","charLengthMaskIntParseIntNaN","charLengthMaskInt","assertIsValidTextEncoder","textEncoder","Array","isArray","assertIsValidCharLengthType","charLengthType","chunkLength","characters","length","charactersArray","map","character","encode","reduce","accumulator","currentValue","arrayLength","maxLength","lastSpaceOrLength","upTo","lastIndex","lastIndexOf","chunkIndexOf","splitAt","slice","_default","chunkSizeInt","charLengthMaskIntParseInt","textEncoderObject","hasOwnProperty","call","TextEncoder","ex","ReferenceError","chunks","chunk","join","trim","push","module","default"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAAC,SAAD,CAAP,GAAqB,KAAK,CAA1B;;AAEA,IAAIE,MAAM,GAAGC,sBAAsB,CAACC,OAAO,CAAC,OAAD,CAAR,CAAnC;;AAEA,SAASD,sBAAT,CAAgCE,GAAhC,EAAqC;AAAE,SAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;AAAE,eAAWA;AAAb,GAArC;AAA0D;;AAEjG,SAASE,OAAT,CAAiBF,GAAjB,EAAsB;AAAE;;AAA2B,MAAI,OAAOG,MAAP,KAAkB,UAAlB,IAAgC,OAAOA,MAAM,CAACC,QAAd,KAA2B,QAA/D,EAAyE;AAAEF,IAAAA,OAAO,GAAG,SAASA,OAAT,CAAiBF,GAAjB,EAAsB;AAAE,aAAO,OAAOA,GAAd;AAAoB,KAAtD;AAAyD,GAApI,MAA0I;AAAEE,IAAAA,OAAO,GAAG,SAASA,OAAT,CAAiBF,GAAjB,EAAsB;AAAE,aAAOA,GAAG,IAAI,OAAOG,MAAP,KAAkB,UAAzB,IAAuCH,GAAG,CAACK,WAAJ,KAAoBF,MAA3D,IAAqEH,GAAG,KAAKG,MAAM,CAACG,SAApF,GAAgG,QAAhG,GAA2G,OAAON,GAAzH;AAA+H,KAAjK;AAAoK;;AAAC,SAAOE,OAAO,CAACF,GAAD,CAAd;AAAsB;;AAE1X,IAAIO,iBAAiB,GAAG,SAASA,iBAAT,CAA2BC,IAA3B,EAAiC;AACvD,MAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC5B,UAAM,IAAIC,SAAJ,CAAc,4DAAd,CAAN;AACD;AACF,CAJD;;AAMA,IAAIC,sBAAsB,GAAG,SAASA,sBAAT,CAAgCC,SAAhC,EAA2C;AACtE,MAAIC,MAAM,CAACC,KAAP,CAAaF,SAAb,KAA2BC,MAAM,CAACE,QAAP,CAAgBH,SAAhB,EAA2B,EAA3B,KAAkC,CAAjE,EAAoE;AAClE,UAAM,IAAIF,SAAJ,CAAc,oFAAd,CAAN;AACD;AACF,CAJD;;AAMA,IAAIM,yBAAyB,GAAG,SAASA,yBAAT,CAAmCC,YAAnC,EAAiD;AAC/E,MAAId,OAAO,CAACc,YAAD,CAAP,KAA0B,QAA1B,IAAsC,OAAOA,YAAP,KAAwB,WAA9D,IAA6EA,YAAY,KAAK,IAA9F,IAAsGA,YAAY,KAAK,EAA3H,EAA+H;AAC7H,UAAM,IAAIP,SAAJ,CAAc,8EAA8E,uGAA5F,CAAN;AACD;AACF,CAJD;;AAMA,IAAIQ,2BAA2B,GAAG,SAASA,2BAAT,CAAqCC,cAArC,EAAqDC,4BAArD,EAAmFC,iBAAnF,EAAsG;AACtI,MAAID,4BAA4B,IAAIC,iBAAiB,GAAG,CAAC,CAAzD,EAA4D;AAC1D,UAAM,IAAIX,SAAJ,CAAc,6FAAd,CAAN;AACD;AACF,CAJD;;AAMA,IAAIY,wBAAwB,GAAG,SAASA,wBAAT,CAAkCC,WAAlC,EAA+C;AAC5E,MAAI,OAAOA,WAAP,KAAuB,QAAvB,IAAmCC,KAAK,CAACC,OAAN,CAAcF,WAAd,CAAnC,IAAiE,OAAOA,WAAP,KAAuB,WAAxF,IAAuGA,WAAW,KAAK,IAA3H,EAAiI;AAC/H,UAAM,IAAIb,SAAJ,CAAc,0HAAd,CAAN;AACD;AACF,CAJD;;AAMA,IAAIgB,2BAA2B,GAAG,SAASA,2BAAT,CAAqCC,cAArC,EAAqD;AACrF,MAAI,OAAOA,cAAP,KAA0B,QAA1B,IAAsC,EAAEA,cAAc,KAAK,QAAnB,IAA+BA,cAAc,KAAK,aAApD,CAA1C,EAA8G;AAC5G,UAAM,IAAIjB,SAAJ,CAAc,0GAAd,CAAN;AACD;AACF,CAJD;;AAMA,IAAIkB,WAAW,GAAG,SAASA,WAAT,CAAqBC,UAArB,EAAiCV,cAAjC,EAAiDQ,cAAjD,EAAiEJ,WAAjE,EAA8E;AAC9F,MAAIO,MAAJ;;AAEA,MAAI,OAAOD,UAAP,KAAsB,WAAtB,IAAqCA,UAAU,KAAK,IAApD,IAA4DA,UAAU,KAAK,EAA/E,EAAmF;AACjFC,IAAAA,MAAM,GAAG,CAAC,CAAV;AACD,GAFD,MAEO;AACL,QAAIC,eAAJ;;AAEA,QAAI,OAAOF,UAAP,KAAsB,QAA1B,EAAoC;AAClCE,MAAAA,eAAe,GAAG,CAACF,UAAD,CAAlB;AACD,KAFD,MAEO,IAAIL,KAAK,CAACC,OAAN,CAAcI,UAAd,KAA6BA,UAAU,CAACC,MAA5C,EAAoD;AACzDC,MAAAA,eAAe,GAAGF,UAAlB;AACD;;AAED,QAAI,CAACL,KAAK,CAACC,OAAN,CAAcM,eAAd,CAAD,IAAmC,CAACA,eAAe,CAACD,MAApD,IAA8DC,eAAe,KAAK,IAAtF,EAA4F;AAC1FD,MAAAA,MAAM,GAAG,CAAC,CAAV;AACD,KAFD,MAEO,IAAIX,cAAc,KAAK,CAAvB,EAA0B;AAC/BW,MAAAA,MAAM,GAAGC,eAAe,CAACC,GAAhB,CAAoB,UAAUC,SAAV,EAAqB;AAChD,eAAO,CAACN,cAAc,KAAK,aAAnB,GAAmCJ,WAAW,CAACW,MAAZ,CAAmBD,SAAnB,CAAnC,GAAmEA,SAApE,EAA+EH,MAAtF;AACD,OAFQ,EAENK,MAFM,CAEC,UAAUC,WAAV,EAAuBC,YAAvB,EAAqC;AAC7C,eAAOD,WAAW,GAAGC,YAArB;AACD,OAJQ,CAAT;AAKD,KANM,MAMA,IAAIlB,cAAc,GAAG,CAArB,EAAwB;AAC7B,UAAImB,WAAW,GAAGP,eAAe,CAACC,GAAhB,CAAoB,UAAUC,SAAV,EAAqB;AACzD,eAAO,CAACN,cAAc,KAAK,aAAnB,GAAmCJ,WAAW,CAACW,MAAZ,CAAmBD,SAAnB,CAAnC,GAAmEA,SAApE,EAA+EH,MAAtF;AACD,OAFiB,EAEfK,MAFe,CAER,UAAUC,WAAV,EAAuBC,YAAvB,EAAqC;AAC7C,eAAOD,WAAW,IAAIC,YAAY,GAAGlB,cAAf,GAAgCA,cAAhC,GAAiDkB,YAArD,CAAlB;AACD,OAJiB,CAAlB;AAKA,UAAIE,SAAS,GAAGR,eAAe,CAACD,MAAhB,GAAyBX,cAAzC;AACAW,MAAAA,MAAM,GAAGS,SAAS,GAAGD,WAAZ,GAA0BA,WAA1B,GAAwCC,SAAjD;AACD,KARM,MAQA;AACLT,MAAAA,MAAM,GAAGC,eAAe,CAACD,MAAzB;AACD;AACF;;AAED,SAAOA,MAAP;AACD,CApCD;;AAsCA,IAAIU,iBAAiB,GAAG,SAASA,iBAAT,CAA2B/B,IAA3B,EAAiCgC,IAAjC,EAAuC;AAC7D,MAAIC,SAAS,GAAGjC,IAAI,CAACkC,WAAL,CAAiB,GAAjB,EAAsBF,IAAtB,CAAhB;;AAEA,MAAIC,SAAS,KAAK,CAAC,CAAnB,EAAsB;AACpBA,IAAAA,SAAS,GAAGD,IAAZ;AACD;;AAED,MAAIC,SAAS,GAAGjC,IAAI,CAACqB,MAAjB,IAA2BW,IAAI,IAAIhC,IAAI,CAACqB,MAA5C,EAAoD;AAClDY,IAAAA,SAAS,GAAGjC,IAAI,CAACqB,MAAjB;AACD;;AAED,SAAOY,SAAP;AACD,CAZD;;AAcA,IAAIE,YAAY,GAAG,SAASA,YAAT,CAAsBf,UAAtB,EAAkCjB,SAAlC,EAA6CO,cAA7C,EAA6DQ,cAA7D,EAA6EJ,WAA7E,EAA0F;AAC3G,MAAIsB,OAAO,GAAGL,iBAAiB,CAACX,UAAD,EAAajB,SAAb,CAA/B;;AAEA,SAAOiC,OAAO,GAAG,CAAV,IAAejC,SAAS,GAAGgB,WAAW,CAACC,UAAU,CAACiB,KAAX,CAAiB,CAAjB,EAAoBD,OAApB,CAAD,EAA+B1B,cAA/B,EAA+CQ,cAA/C,EAA+DJ,WAA/D,CAA7C,EAA0H;AACxHsB,IAAAA,OAAO,GAAGA,OAAO,GAAG,CAApB;AACD;;AAEDA,EAAAA,OAAO,GAAGL,iBAAiB,CAACX,UAAD,EAAagB,OAAb,CAA3B;;AAEA,MAAIA,OAAO,GAAG,CAAC,CAAX,IAAgBA,OAAO,GAAG,CAA1B,IAA+BhB,UAAU,CAACgB,OAAD,CAAV,KAAwB,GAA3D,EAAgE;AAC9DA,IAAAA,OAAO,GAAGA,OAAO,GAAG,CAApB;AACD;;AAED,MAAIA,OAAO,GAAGhB,UAAU,CAACC,MAArB,IAA+Be,OAAO,GAAG,CAAzC,IAA8CA,OAAO,KAAK,CAAZ,IAAiBhB,UAAU,CAACC,MAAX,KAAsB,CAAzF,EAA4F;AAC1Fe,IAAAA,OAAO,GAAGhB,UAAU,CAACC,MAArB;AACD;;AAED,SAAOe,OAAP;AACD,CAlBD;;AAoBA,IAAIE,QAAQ,GAAG,SAASA,QAAT,CAAkBtC,IAAlB,EAAwBG,SAAxB,EAAmCK,YAAnC,EAAiD;AAC9DT,EAAAA,iBAAiB,CAACC,IAAD,CAAjB;AACA,MAAIuC,YAAY,GAAGnC,MAAM,CAACE,QAAP,CAAgBH,SAAhB,EAA2B,EAA3B,CAAnB;AACAD,EAAAA,sBAAsB,CAACqC,YAAD,CAAtB;AACAhC,EAAAA,yBAAyB,CAACC,YAAD,CAAzB;AACA,MAAII,iBAAiB,GAAG,CAAC,CAAzB;AACA,MAAI4B,yBAAyB,GAAG,CAAC,CAAjC;AACA,MAAI7B,4BAA4B,GAAG,IAAnC;AACA,MAAI8B,iBAAJ;;AAEA,MAAI/C,OAAO,CAACc,YAAD,CAAP,KAA0B,QAA9B,EAAwC;AACtC,QAAIvB,MAAM,CAACa,SAAP,CAAiB4C,cAAjB,CAAgCC,IAAhC,CAAqCnC,YAArC,EAAmD,gBAAnD,CAAJ,EAA0E;AACxEI,MAAAA,iBAAiB,GAAGJ,YAAY,CAACE,cAAjC;AACA8B,MAAAA,yBAAyB,GAAGpC,MAAM,CAACE,QAAP,CAAgBM,iBAAhB,EAAmC,EAAnC,CAA5B;AACAD,MAAAA,4BAA4B,GAAGP,MAAM,CAACC,KAAP,CAAamC,yBAAb,CAA/B;AACA/B,MAAAA,2BAA2B,CAACG,iBAAD,EAAoBD,4BAApB,EAAkD6B,yBAAlD,CAA3B;AACD;;AAED,QAAIvD,MAAM,CAACa,SAAP,CAAiB4C,cAAjB,CAAgCC,IAAhC,CAAqCnC,YAArC,EAAmD,gBAAnD,CAAJ,EAA0E;AACxES,MAAAA,2BAA2B,CAACT,YAAY,CAACU,cAAd,CAA3B;;AAEA,UAAIV,YAAY,CAACU,cAAb,KAAgC,aAApC,EAAmD;AACjD,YAAIjC,MAAM,CAACa,SAAP,CAAiB4C,cAAjB,CAAgCC,IAAhC,CAAqCnC,YAArC,EAAmD,aAAnD,CAAJ,EAAuE;AACrEK,UAAAA,wBAAwB,CAACL,YAAY,CAACM,WAAd,CAAxB;AACA2B,UAAAA,iBAAiB,GAAGjC,YAAY,CAACM,WAAjC;AACD;AACF;AACF;AACF;;AAED,MAAIJ,cAAc,GAAGC,4BAA4B,GAAG,CAAC,CAAJ,GAAQ6B,yBAAzD;AACA,MAAItB,cAAc,GAAGxB,OAAO,CAACc,YAAD,CAAP,KAA0B,QAA1B,IAAsCA,YAAY,CAACU,cAAnD,GAAoEV,YAAY,CAACU,cAAjF,GAAkG,QAAvH;;AAEA,MAAI;AACF,QAAIA,cAAc,KAAK,aAAnB,KAAqC,OAAOuB,iBAAP,KAA6B,WAA7B,IAA4CA,iBAAiB,KAAK,IAAlE,IAA0EA,iBAAiB,KAAK,EAArI,CAAJ,EAA8I;AAC5IA,MAAAA,iBAAiB,GAAG,IAAIG,WAAJ,EAApB;AACD;AACF,GAJD,CAIE,OAAOC,EAAP,EAAW;AACX,UAAM,IAAIC,cAAJ,CAAmB,sHAAnB,CAAN;AACD;;AAED,MAAIhC,WAAW,GAAG2B,iBAAlB;AACA,MAAIM,MAAM,GAAG,EAAb;AACA,MAAI3B,UAAU,GAAG,CAAC,GAAG/B,MAAM,CAAC,SAAD,CAAV,EAAuBW,IAAvB,CAAjB;;AAEA,SAAOmB,WAAW,CAACC,UAAD,EAAaV,cAAb,EAA6BQ,cAA7B,EAA6CJ,WAA7C,CAAX,GAAuE,CAA9E,EAAiF;AAC/E,QAAIsB,OAAO,GAAGD,YAAY,CAACf,UAAD,EAAamB,YAAb,EAA2B7B,cAA3B,EAA2CQ,cAA3C,EAA2DJ,WAA3D,CAA1B;AACA,QAAIkC,KAAK,GAAG5B,UAAU,CAACiB,KAAX,CAAiB,CAAjB,EAAoBD,OAApB,EAA6Ba,IAA7B,CAAkC,EAAlC,EAAsCC,IAAtC,EAAZ;;AAEA,QAAIF,KAAK,KAAK,EAAV,IAAgBA,KAAK,KAAK,IAA9B,EAAoC;AAClCD,MAAAA,MAAM,CAACI,IAAP,CAAYH,KAAZ;AACD;;AAED5B,IAAAA,UAAU,GAAGA,UAAU,CAACiB,KAAX,CAAiBD,OAAjB,CAAb;AACD;;AAED,SAAOW,MAAP;AACD,CAzDD;;AA2DA5D,OAAO,CAAC,SAAD,CAAP,GAAqBmD,QAArB;AACAc,MAAM,CAACjE,OAAP,GAAiBA,OAAO,CAACkE,OAAzB","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _runes = _interopRequireDefault(require(\"runes\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar assertIsValidText = function assertIsValidText(text) {\n  if (typeof text !== 'string') {\n    throw new TypeError('Text should be provided as first argument and be a string.');\n  }\n};\n\nvar assertIsValidChunkSize = function assertIsValidChunkSize(chunkSize) {\n  if (Number.isNaN(chunkSize) || Number.parseInt(chunkSize, 10) <= 0) {\n    throw new TypeError('Size should be provided as 2nd argument and parseInt to a value greater than zero.');\n  }\n};\n\nvar assertIsValidChunkOptions = function assertIsValidChunkOptions(chunkOptions) {\n  if (_typeof(chunkOptions) !== 'object' && typeof chunkOptions !== 'undefined' && chunkOptions !== null && chunkOptions !== '') {\n    throw new TypeError('Options should be provided as 3rd (optional) argument and be an object.\\n' + \"Potential chunkOptions object properties include: ['charLengthMask', 'charLengthType', 'textEncoder']\");\n  }\n};\n\nvar assertIsValidCharLengthMask = function assertIsValidCharLengthMask(charLengthMask, charLengthMaskIntParseIntNaN, charLengthMaskInt) {\n  if (charLengthMaskIntParseIntNaN || charLengthMaskInt < -1) {\n    throw new TypeError('charLengthMask should be provided as a chunkOptions property and parseInt to a value >= -1.');\n  }\n};\n\nvar assertIsValidTextEncoder = function assertIsValidTextEncoder(textEncoder) {\n  if (typeof textEncoder === 'string' || Array.isArray(textEncoder) || typeof textEncoder === 'undefined' || textEncoder === null) {\n    throw new TypeError('textEncoder should be provided as a chunkOptions property and be an object containing the .encode(text).length property.');\n  }\n};\n\nvar assertIsValidCharLengthType = function assertIsValidCharLengthType(charLengthType) {\n  if (typeof charLengthType !== 'string' || !(charLengthType === 'length' || charLengthType === 'TextEncoder')) {\n    throw new TypeError(\"charLengthType should be provided as a chunkOptions property and be a value in ['length', 'TextEncoder']\");\n  }\n};\n\nvar chunkLength = function chunkLength(characters, charLengthMask, charLengthType, textEncoder) {\n  var length;\n\n  if (typeof characters === 'undefined' || characters === null || characters === '') {\n    length = -1;\n  } else {\n    var charactersArray;\n\n    if (typeof characters === 'string') {\n      charactersArray = [characters];\n    } else if (Array.isArray(characters) && characters.length) {\n      charactersArray = characters;\n    }\n\n    if (!Array.isArray(charactersArray) || !charactersArray.length || charactersArray === null) {\n      length = -1;\n    } else if (charLengthMask === 0) {\n      length = charactersArray.map(function (character) {\n        return (charLengthType === 'TextEncoder' ? textEncoder.encode(character) : character).length;\n      }).reduce(function (accumulator, currentValue) {\n        return accumulator + currentValue;\n      });\n    } else if (charLengthMask > 0) {\n      var arrayLength = charactersArray.map(function (character) {\n        return (charLengthType === 'TextEncoder' ? textEncoder.encode(character) : character).length;\n      }).reduce(function (accumulator, currentValue) {\n        return accumulator + (currentValue > charLengthMask ? charLengthMask : currentValue);\n      });\n      var maxLength = charactersArray.length * charLengthMask;\n      length = maxLength > arrayLength ? arrayLength : maxLength;\n    } else {\n      length = charactersArray.length;\n    }\n  }\n\n  return length;\n};\n\nvar lastSpaceOrLength = function lastSpaceOrLength(text, upTo) {\n  var lastIndex = text.lastIndexOf(' ', upTo);\n\n  if (lastIndex === -1) {\n    lastIndex = upTo;\n  }\n\n  if (lastIndex > text.length || upTo >= text.length) {\n    lastIndex = text.length;\n  }\n\n  return lastIndex;\n};\n\nvar chunkIndexOf = function chunkIndexOf(characters, chunkSize, charLengthMask, charLengthType, textEncoder) {\n  var splitAt = lastSpaceOrLength(characters, chunkSize);\n\n  while (splitAt > 0 && chunkSize < chunkLength(characters.slice(0, splitAt), charLengthMask, charLengthType, textEncoder)) {\n    splitAt = splitAt - 1;\n  }\n\n  splitAt = lastSpaceOrLength(characters, splitAt);\n\n  if (splitAt > -2 && splitAt < 1 || characters[splitAt] === ' ') {\n    splitAt = splitAt + 1;\n  }\n\n  if (splitAt > characters.length || splitAt < 0 || splitAt === 0 && characters.length === 1) {\n    splitAt = characters.length;\n  }\n\n  return splitAt;\n};\n\nvar _default = function _default(text, chunkSize, chunkOptions) {\n  assertIsValidText(text);\n  var chunkSizeInt = Number.parseInt(chunkSize, 10);\n  assertIsValidChunkSize(chunkSizeInt);\n  assertIsValidChunkOptions(chunkOptions);\n  var charLengthMaskInt = -1;\n  var charLengthMaskIntParseInt = -1;\n  var charLengthMaskIntParseIntNaN = true;\n  var textEncoderObject;\n\n  if (_typeof(chunkOptions) === 'object') {\n    if (Object.prototype.hasOwnProperty.call(chunkOptions, 'charLengthMask')) {\n      charLengthMaskInt = chunkOptions.charLengthMask;\n      charLengthMaskIntParseInt = Number.parseInt(charLengthMaskInt, 10);\n      charLengthMaskIntParseIntNaN = Number.isNaN(charLengthMaskIntParseInt);\n      assertIsValidCharLengthMask(charLengthMaskInt, charLengthMaskIntParseIntNaN, charLengthMaskIntParseInt);\n    }\n\n    if (Object.prototype.hasOwnProperty.call(chunkOptions, 'charLengthType')) {\n      assertIsValidCharLengthType(chunkOptions.charLengthType);\n\n      if (chunkOptions.charLengthType === 'TextEncoder') {\n        if (Object.prototype.hasOwnProperty.call(chunkOptions, 'textEncoder')) {\n          assertIsValidTextEncoder(chunkOptions.textEncoder);\n          textEncoderObject = chunkOptions.textEncoder;\n        }\n      }\n    }\n  }\n\n  var charLengthMask = charLengthMaskIntParseIntNaN ? -1 : charLengthMaskIntParseInt;\n  var charLengthType = _typeof(chunkOptions) === 'object' && chunkOptions.charLengthType ? chunkOptions.charLengthType : 'length';\n\n  try {\n    if (charLengthType === 'TextEncoder' && (typeof textEncoderObject === 'undefined' || textEncoderObject === null || textEncoderObject === '')) {\n      textEncoderObject = new TextEncoder();\n    }\n  } catch (ex) {\n    throw new ReferenceError(\"TextEncoder is not natively defined, new TextEncoder must be passed in with the 'chunkOptions.textEncoder' property.\");\n  }\n\n  var textEncoder = textEncoderObject;\n  var chunks = [];\n  var characters = (0, _runes[\"default\"])(text);\n\n  while (chunkLength(characters, charLengthMask, charLengthType, textEncoder) > 0) {\n    var splitAt = chunkIndexOf(characters, chunkSizeInt, charLengthMask, charLengthType, textEncoder);\n    var chunk = characters.slice(0, splitAt).join('').trim();\n\n    if (chunk !== '' && chunk !== null) {\n      chunks.push(chunk);\n    }\n\n    characters = characters.slice(splitAt);\n  }\n\n  return chunks;\n};\n\nexports[\"default\"] = _default;\nmodule.exports = exports.default;"]},"metadata":{},"sourceType":"script"}